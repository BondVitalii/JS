// МАСИВЫ
//=======================================================================
/** Створення масиву
|============================

// Масив оголошується і береться у квадратні дужки[] - літералом масиву.
// Всередині дужок кожен елемент масиву розділяється комою.

const clients = ["Mango", "Poly", "Ajax"];

|============================
*/
// ______________________________________________________________________
/** Доступ до елементів
|============================

// Для доступу до значення елемента масиву використовується синтаксис квадратних дужок масив[індекс].
// Між іменем змінної, що зберігає масив, і квадратними дужками не повинно бути пробілу.

const clients = ["Mango", "Poly", "Ajax"];

Зазначаючи в дужках індекс елемента, ми отримуємо його значення
console.log(clients[0]); // Mango
console.log(clients[1]); // Poly
console.log(clients[2]); // Ajax

|============================
*/
// ______________________________________________________________________
/** Перевизначення
|============================

// На відміну від рядків, елементи масиву можна змінювати, звернувшись до них за індексом і присвоївши інше значення.

const clients = ['Mango', 'Poly', 'Ajax'];
clients[0] = 'Kiwi';
clients[1] = 'Pango';
console.log(clients); // ["Kiwi", "Pango", "Ajax"]

|============================
*/
// ______________________________________________________________________
/** Довжина масиву
|============================

// Довжина масиву, тобто кількість його елементів, зберігається у властивості length.
// Це динамічна величина, яка змінюється автоматично під час додавання або видалення елементів.

const clients = ["Mango", "Poly", "Ajax"];
console.log(clients.length); // 3

|============================
*/
// ______________________________________________________________________
/** Індекс останнього елемента
|============================

// Найчастіше, ми заздалегідь не знаємо яка буде довжина масиву в коді.
// Для того, щоб отримати значення останнього елемента, застосовується наступний підхід
// - довжина масиву завжди на одиницю більша, ніж індекс останнього елемента.
// Використовуючи формулу довжина_масиву - 1, можна отримати значення останнього елемента масиву довільної довжини.

const clients = ["Mango", "Poly", "Ajax"];
const lastElementIndex = clients.length - 1;
console.log(lastElementIndex); // 2
console.log(clients[lastElementIndex]); // "Ajax"

|============================
*/
// ______________________________________________________________________
/** Цикл for
|============================

// Цикл for можна використовувати для ітерації по масиву, тобто «перебрати» його поелементно.

const clients = ['Mango', 'Ajax', 'Poly'];

for (let i = 0; i < clients.length; i += 1) {
  console.log(clients[i]); // Mango Ajax Poly
}

// Для доступу до елементів використовується синтаксис квадратних дужок масив[індекс],
// де індекс - це значення лічильника циклу від 0 і до останнього індексу масиву,
// тобто менше, але не дорівнює його довжині.

|============================
*/
// ______________________________________________________________________
/** Цикл for...of
|============================

// Конструкція for...of оголошує цикл, що перебирає ітерабельні об'єкти, як-от масиви і рядки.
// Тіло циклу буде виконуватися для значення кожного елемента.
// Це хороша заміна циклу for, якщо не потрібен доступ до лічильника ітерації.

for (const variable of iterable) {
  // тіло циклу
}

// variable — змінна, яка буде зберігати значення елемента на кожній ітерації.
// iterable — колекція, яка містить ітерабельні (що можна порахувати) елементи, наприклад масив.

const clients = ['Mango', 'Ajax', 'Poly'];

for (const client of clients) {
  console.log(client);
}

const string = 'javascript';

for (const character of string) {
  console.log(character);
}

|============================
*/
// ______________________________________________________________________
/** Оператори break і continue
|============================

// Будемо шукати ім'я клієнта в масиві імен, 
// якщо знайшли - перериваємо цикл, оскільки немає сенсу шукати далі, імена у нас унікальні.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message;

for (const client of clients) {
  // На кожній ітерації будемо перевіряти чи збігається елемент масиву з іменем клієнта. 
  // Якщо збігається - записуємо в message повідомлення про успіх і робимо break, щоб далі не шукати.

  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }

  // Якщо вони не збігаються - записуємо в message повідомлення про відсутність імені.

  message = "Клієнт з таким ім'ям відсутній в базі даних!";
}

console.log(message); // "Клієнт з таким ім'ям є в базі даних!"

// ------------------

// Можна на початку задати message значення невдачі пошуку, а в циклі перезаписати його на успіх, якщо знайшли ім'я.
// Але break все одно нам знадобиться, оскільки, якщо у нас масив із 10000 клієнтів, а потрібний нам знаходиться на 2 позиції,
// то немає абсолютно жодного сенсу перебирати інші 9998 елементи.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message = "Клієнт з таким ім'ям відсутній в базі даних!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }
  // Якщо не збігається, то на цій ітерації нічого не робимо
}

console.log(message); // Клієнт з таким ім'ям є в базі даних!

|============================
*/
// ______________________________________________________________________
/** Використовуємо цикл для виведення тільки чисел, більших за певне значення.
|============================

const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
const threshold = 15;

// // Для чисел, менших ніж порогове значення, спрацьовує continue, виконання тіла
// // припиняється і управління передається на наступну ітерацію.

for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }

  console.log(`Число більше за ${threshold}: ${numbers[i]}`); // 18, 29, 34
}

|============================
*/
// ______________________________________________________________________
/** Присвоєння за посиланням і за значенням
|============================

// Фундаментальною відмінністю складних типів від примітивів є те, як вони зберігаються і копіюються.
// Примітиви: рядки, числа, булі, null і undefined, під час присвоєння повністю копіюються за значенням(by value).

// Зі складними типами - все по-іншому.
// У змінній, якій присвоєно масив або об'єкт, зберігається не саме значення,
// а адреса його місця в пам'яті, іншими словами - посилання(вказівник) на нього і вони передаються за посиланням(by reference).

// Уявімо змінну у вигляді аркушу паперу. Її значення ми уявимо як запис на цьому аркуші.

// Якщо ми захочемо повідомити зміст цього запису користувачам,
// то можемо це зробити наступним чином - зробити фізичні копії і вручити кожному,
// тобто зробити багато незалежних копій(присвоєння за значенням).

// Або покласти аркуш в зачиненій кімнаті і дати користувачам ключ від цієї кімнати,
// тобто один екземпляр із загальним доступом(присвоєння за посиланням).

// Тепер змінимо дані на аркуші паперу - значення змінної.
// Очевидно, що відвідувачі кімнати завжди будуть бачити зміни, які ми вносимо, оскільки змінюється оригінал і вони мають до нього доступ.
// І також очевидно, що власники паперових копій не помітять змін, дивлячись на свої копії.

// За умови передачі за значенням, змінним виділяється нова комірка пам'яті і в неї копіюються дані.
// Аналогія з багатьма копіями паперового аркушу має цілком реальне втілення, окремий аркуш для кожної копії.

// За умови передачі за посиланням, замість створення нового об'єкта, змінній присвоюється посилання (вказівник) на вже існуючий об'єкт,
// тобто на його місце в пам'яті.
// Таким чином, декілька змінних можуть вказувати на один і той самий об'єкт,
// за аналогією із закритою кімнатою, вони мають ключ доступу до оригіналу аркушу.

// Усі примітивні типи присвоюються за значенням, тобто створюється копія.

let a = 5;
// Присвоєння за значенням, в пам'яті буде створена ще
// одна комірка, в яку буде скопійоване значення 5
let b = a;
console.log(a); // 5
console.log(b); // 5

// Змінимо значення a
a = 10;
console.log(a); // 10
// Значення b не змінилося, оскільки це окрема копія
console.log(b); // 5

// --------------------------------------------------
// Складні типи

// Складні типи - об'єкти, масиви, функції присвоюються за посиланням, 
// тобто змінна просто отримує посилання на вже існуючий об'єкт.



const a = ["Mango"];
// Оскільки a - це масив, в b записується посилання на вже існуючий
// масив в пам'яті. Тепер a і b вказують на той самий масив.
const b = a;
console.log(a); // ["Mango"]
console.log(b); // ["Mango"]

// Змінимо масив, додавши ще один елемент, використовуючи вказівник з a
a.push("Poly");
console.log(a); // ["Mango", "Poly"]

// b також змінилось, тому що b, як і a,
// просто містить посилання на те ж саме місце в пам'яті
console.log(b); // ["Mango", "Poly"]

// Результат повторюється
b.push("Ajax");
console.log(a); // ["Mango", "Poly", "Ajax"]
console.log(b); // ["Mango", "Poly", "Ajax"]

|============================
*/
// ______________________________________________________________________
// ======================================================================
// Методи масиву
// -------------
// Методи split() і join()
// -----------------------
/** Метод split(delimiter)
|============================
// Метод split(delimiter) перетворює рядок в масив, «розбиваючи» його роздільником delimiter. 
// Якщо роздільник - це порожній рядок, то створиться масив окремих символів.
// Роздільником може бути один або декілька символів.

const name = 'Mango';
console.log(name.split('')); // ["M", "a", "n", "g", "o"]

const message = 'JavaScript - це цікаво';
console.log(message.split(' ')); // ["JavaScript", "-", "це", "цікаво"]
|============================
*/
// -------------
/** Метод масивів join(delimiter)
|============================
// Метод масивів join(delimiter) об'єднує елементи масиву у рядок. 
// У рядку елементи будуть розділені символом або групою символів, зазначених в delimiter.
// Тобто ця операція протилежна методу рядків split(delimiter).

const words = ["JavaScript", "це", "цікаво"];
console.log(words.join("")); // "JavaScriptцецікаво"
console.log(words.join(" ")); // "JavaScript це цікаво"
console.log(words.join("-")); // "JavaScript-це-цікаво"
|============================
*/
// ----------------------------------------------
/** Метод indexOf()
|============================
// indexOf(value) повертає перший індекс, в якому елемент зі значенням value був знайдений в масиві,
// або число - 1, якщо такий елемент відсутній.
// Використовуйте indexOf тоді, коли необхідно отримати сам індекс елемента.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1
|============================
*/
// ----------------------------------------------
/** Метод includes()
|============================

// includes(value) перевіряє, чи містить масив елемент зі значенням value і повертає true або false відповідно.
// Застосування цього методу корисне в ситуаціях, коли необхідно перевірити, чи є елемент в масиві і не важлива його позиція(індекс).

const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
console.log(clients.includes('Poly')); // true
console.log(clients.includes('Monkong')); // false

// Перевірка багатьох умов з includes()
// На перший погляд код наступного прикладу виглядає добре.

const fruit = 'apple';

if (fruit === 'apple' || fruit === 'strawberry') {
  console.log('It is a red fruit!');
}

// Однак, що робити, якщо у нас буде більше червоних фруктів, наприклад, ще вишня(cherry) або журавлина(cranberries) ?
// Чи будемо ми розширювати умову за допомогою додаткових ||?

const fruit = 'apple';

if (
  fruit === 'apple' ||
  fruit === 'strawberry' ||
  fruit === 'cherry' ||
  fruit === 'cranberries'
) {
  console.log('It is a red fruit!');
}

// Можемо переписати умову, використовуючи includes(), це дуже просто і масштабовано.

// Виносимо варіанти в масив
const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
const fruit = "cherry";
// Перевіряємо присутність елемента
const hasFruit = redFruits.includes(fruit);

if (hasFruit) {
  console.log(`${fruit} is a red fruit!`);
}

|============================
*/
// ----------------------------------------------
// Методи push() і pop()
// -----------------------
// Додають або видаляють крайні елементи масиву.
// Працюють тільки з крайнім лівим і крайнім правим елементом, і не можуть вставити або видалити елемент з довільної позиції.

/** Метод push()
|============================

// Метод push() додає один або декілька елементів наприкінці масиву, без необхідності зазначати індекси елементів, що додаються.
// Повертає довжину масиву після додавання елементів.

const numbers = [];

numbers.push(1);
console.log(numbers); // [1]

numbers.push(2);
console.log(numbers); // [1, 2]

numbers.push(3);
console.log(numbers); // [1, 2, 3]

numbers.push(4);
console.log(numbers); // [1, 2, 3, 4]

numbers.push(5);
console.log(numbers); // [1, 2, 3, 4, 5]

|============================
*/
// -------------
/** Метод pop()
|============================

 // Метод pop() видаляє останній елемент з кінця масиву і повертає видалений елемент.
 // Якщо масив порожній, метод повертає undefined.

 const numbers = [1, 2, 3, 4, 5];

 console.log(numbers.pop()); //  5
 console.log(numbers); // [1, 2, 3, 4]

 console.log(numbers.pop()); //  4
 console.log(numbers); // [1, 2, 3]

 console.log(numbers.pop()); //  3
 console.log(numbers); // [1, 2]

 console.log(numbers.pop()); //  2
 console.log(numbers); // [1]

 console.log(numbers.pop()); //  1
 console.log(numbers); // []

|============================
*/
// ----------------------------------------------
/** Метод slice()
 |============================
 
 // slice(begin, end) повертає новий масив, що містить копію частини вихідного масиву, не змінюючи його.
 // Копія створюється з begin і до, але не включно, end - індекси елементів вихідного масиву.
 
 const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
 console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]
 
 // Якщо begin і end не зазначені, буде створена повна копія вихідного масиву.
 
 const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
 console.log(clients.slice()); // ["Mango", Ajax", "Poly", "Kiwi"]
 
 // Якщо не зазначено end, копіювання буде зі start і до кінця вихідного масиву.
 
 const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
 console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]
 console.log(clients.slice(2)); // ["Poly", "Kiwi"]
 
 // Якщо значення start від'ємне, а end не зазначено - будуть скопійовані останні start елементи
 
 const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
 console.log(clients.slice(-2)); // ["Poly", "Kiwi"]
 
 |============================
 */
// ----------------------------------------------
/** Метод splice()
 |============================

    // Швейцарський ніж для роботи з масивами, якщо вихідний масив необхідно змінити.
    // Видаляє, додає і замінює елементи у довільному місці масиву.

    // =========
    // Видалення
    // =========
    // Щоб видалити елементи в масиві, передаються два аргументи.

    splice(position, num);

    // - position - вказує на позицію (індекс) першого елемента для видалення
    // - num - визначає кількість елементів, що видаляються

    // Метод splice змінює вихідний масив і повертає масив, що містить видалені елементи.
    // Наприклад, у нас є масив оцінок, який містить п'ять чисел від 1 до 5.

    const scores = [1, 2, 3, 4, 5];

    // Видаляємо три елементи масиву, починаючи з першого елемента (індекс 0)
    const deletedScores = scores.splice(0, 3);

    // Тепер масив scores містить два елементи
    console.log(scores); // [4, 5]

    // А масив deletedScores містить три видалені елементи
    console.log(deletedScores); // [1, 2, 3]

    // На зображенні показаний виклик методу score.splice (0, 3) з прикладу.

    // !ЦІКАВО
    // На практиці, значення, що повертається(масив видалених елементів), використовується рідко.
    // Переважно, просто необхідно видалити елементи з масиву.

    // =========
    // Додавання
    // =========
    // Для того, щоб додати один або декілька елементів в масив,
    // необхідно передати три або більше аргументи, за такої умови,
    // другий аргумент повинен дорівнювати нулю.

    // splice(position, 0, new_element_1, new_element_2, ...)

    // - Аргумент position вказує початкову позицію в масиві, куди будуть вставлені нові елементи.
    // - Другий аргумент - це нуль, він говорить методу не видаляти елементи в місці додавання нових.
    // - Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.
    // Наприклад, у нас є масив з назвами кольорів у вигляді рядків. Додамо новий колір перед елементом з індексом 2.

    const colors = ['red', 'green', 'blue'];

    colors.splice(2, 0, 'purple');
    console.log(colors); // ["red", "green", "purple", "blue"]

    // На малюнку показаний виклик методу colors.splice(2, 0, 'purple') з прикладу.

    // Можна додати довільну кількість елементів, передавши четвертий, п'ятий аргумент тощо.

    const colors = ['red', 'green', 'blue'];

    colors.splice(1, 0, 'yellow', 'pink');
    console.log(colors); // ["red", "yellow", "pink", "green", "blue"]

    // =========
    // Заміна
    // =========
    // Заміна - це операція додавання, в якій видаляються елементи в місці додавання нових.
    // Для цього необхідно передати мінімум три аргументи.Кількість елементів, що видаляються і додаються, може не збігатися.

    // splice(position, num, new_element_1, new_element_2, ...)

    // - position - вказує на позицію (індекс) першого елемента для видалення
    // - num - визначає кількість елементів, що видаляються
    // - Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.
    // Наприклад, у нас є масив мов програмування з чотирьох елементів.

    const languages = ['C', 'C++', 'Java', 'JavaScript'];

    // Заміняємо елемент з індексом 1 на новий
    languages.splice(1, 1, 'Python');
    console.log(languages); // ["C", "Python", "Java", "JavaScript"]

    // Заміняємо один елемент (з індексом 2) на декілька
    languages.splice(2, 1, 'C#', 'Swift', 'Go');
    console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]

    // На зображенні показаний виклик методу languages.splice(1, 1, 'Python') з прикладу.

 |============================
 */
// ----------------------------------------------
/** Метод concat()
|============================

// Об'єднує два або більше масивів в один. Він не змінює масив, на якому викликається, а повертає новий.
// Порядок аргументів методу впливає на порядок елементів нового масиву.

const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Monkong", "Singu"];

const allClientsWithOldFirst = oldClients.concat(newClients);
console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

const allClientsWithNewFirst = newClients.concat(oldClients);
console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
console.log(newClients); // ["Monkong", "Singu"]

|============================
*/
// ______________________________________________________________________
// ======================================================================

// const clients = ['Mango', 'Poly', 'Ajax'];
// ------------------------------------
// console.log(clients.length);

// console.log(clients[0]);
// console.log(clients[1]);
// console.log(clients[2]);
// ------------------------------------
// clients[0] = 'Kiwi';

// console.log(clients[0]);

// console.log(clients);
// ------------------------------------
// const lastElementIndex = clients.length - 1;
// console.log(lastElementIndex);
// console.log(clients[lastElementIndex]);
// ------------------------------------
// for (let i = 0; i < clients.length; i += 1) {
//   console.log(clients[i]);
// }
// ------------------------------------
// for (const client of clients) {
//   console.log(client);
// }
// ------------------------------------
// const string = 'javascript';

// for (const character of string) {
//   console.log(character);
// }
// ________________________________________________________________________________________
// Задача:
// Будемо шукати ім'я клієнта в масиві імен, якщо знайшли - перериваємо цикл, оскільки немає сенсу шукати далі, імена у нас унікальні.

// const clients = ['Mango', 'Poly', 'Ajax'];
// const clientNameToFind = 'Poly';

/** Решение:
|============================

const clients = ['Mango', 'Poly', 'Ajax'];
const clientNameToFind = 'Poly';
let message;

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }
  message = "Клієнт з таким ім'ям відсутній в базі даних!";
}
console.log(message);

// -------- 2й вариант ---------

const clients = ['Mango', 'Poly', 'Ajax'];
const clientNameToFind = 'Poly';
let message = "Клієнт з таким ім'ям відсутній в базі даних!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }
}
console.log(message);

|============================
*/
// ________________________________________________________________________________________

// Використовуємо цикл для виведення тільки чисел, більших за певне значення.

// const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
// const threshold = 15;

/** Решение:
|============================

// ----- Вариант-1 for ----------------

for (let i = 0; i < threshold; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }
  console.log(numbers[i]);
}

// ----- Вариант-1 for of --------------

for (const number of numbers) {
  if (number < threshold) {
    continue;
  }
  console.log(number);
}

|============================
*/
// ________________________________________________________________________________________________
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ================================================================================================
// Repeta модуль-2 занятие 1 Масивы
// ================================================================================================
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ________________________________________________________________________________________________
/** Масиві и работа сними.
|============================

const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

console.log(friends);
console.log(friends.length);
console.table(friends);

// -------------------------------------------------------
// Последний индекс

const lastIndex = friends.length - 1;
console.log(lastIndex);

// -------------------------------------------------------

console.log(friends[0]);
console.log(friends[friends.length - 1]);
Это тоже самое что: console.log(['Mango', 'Kiwi', 'Poly', 'Ajax'][0]);

// -------------------------------------------------------

// Запись в масив (перезапись)

const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

friends[0] = 'Orange';

console.table(friends); // ['Orange', 'Kiwi', 'Poly', 'Ajax'];

|============================
*/
// ________________________________________________________________________________________
/** Примитивные типы и Сложные типы
|============================

// Примитивные типы (Передача по значению) Создается точная копия.

// При переназначении значения переменной - создается отдельная ечейка(копия) в памяти.

// let a = 10;
// let b = a;

// console.log(a); // 10
// console.log(b); // 10

// a = 20;

// console.log(a); // 20
// console.log(b); // 10

// =============================================================

// Сложные типы (Передача по ссылке) Копируются по ссылке.

// При создании сложного типа как (масив)
// выделяется отдельное место в памяти для записи этого масива,
// а в переменную записывается ссылка на место где находится этот масив.

// const c = [1, 2, 3];
// const d = c;

// // console.log(c);
// console.log(c); // [1, 2, 3]
// console.log(d); // [1, 2, 3]

// c[0] = 500;

// console.log(c); // [500, 2, 3]
// console.log(d); // [500, 2, 3]

// console.log(c === d); // true - потому что это один и тот же масив, к переменным C и D присвоены ссылки на одну ячеку в памяти где лежит этот масив.

// console.log([1, 2, 3] === [1, 2, 3]); // false - потому что это разные масивы, они не равны, лежат они в разных местах памяти.

|============================
*/
// ________________________________________________________________________________________
/** Цикл for и Цикл for of
|============================
//  Цикл for

//  Перебор масива (итерация масива)

// Задача: Нужно вывести в консоль все значения этого масива

// const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

// console.table(friends);

// console.log(friends.length - 1);

// -----------------------------

// const lastIndex = friends.length - 1;

// for (let i = 0; i <= friends.length - 1; i += 1) {}

// for (let i = 0; i <= lastIndex; i += 1) {
//   console.log('qqqwe');
//   console.log(i);
//   console.log(friends[i]);
// }
// -----------------------------

// for (let i = 0; i < friends.length; i += 1) {
//   friends[i] += '-1';
// }
// console.table(friends);

// =================================================================

//  Цикл for of

// Используем Цикл for of тогда когда нам в задаче не нужен индекс или нам не нужно изменять элемент масива.

// const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

// // for(const variable of iterable) {}

// for (const friend of friends) {
//   console.log(friend);
// }
|============================
*/
// ________________________________________________________________________________________
// Задача-1
// Посчитать общую сумму покупок в корзине.

// const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

/** Решение:
|============================

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

// Наши действия.
// 1 перебрать массив
// 2 сделать переменную total до цикла
// 3 каждый элемент приплюслвать к total

// ----- Вариант-1 for of ------------

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];
let sum = 0;

for (const value of cart) {
  sum += value;
}
console.log('sum: ', sum);

// ----- Вариант-2 for ----------------

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];
let sum = 0;

for (let i = 0; i < cart.length; i += 1) {
  sum += cart[i];
}
console.log('sum: ', sum);

|============================
*/
// ________________________________________________________________________________________
// Задача-2
// Добавить такс (добавить проценты к каждому числу).

// const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

/** Решение:
|============================

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

for (let i = 0; i < cart.length; i += 1) {
  cart[i] = Math.round(cart[i] * 1.1);
}
console.log(cart);

|============================
*/
// ________________________________________________________________________________________
// Задача-3
// Напиши скрипт который подсчитывает сумму всех чётных чисел в массиве.

// const numbers = [1, 5, 8, 9, 12, 4, 15, 27, 30, 18, 14];

/** Решение:
|============================
const numbers = [1, 5, 8, 9, 12, 4, 15, 27, 30, 18, 14];
let sum = 0;

// ----- Вариант-1 ----------------------------------

for (const number of numbers) {
  if (number % 2 === 0) {
    // console.log('четное: ', number);
    sum += number;
  }
}
console.log('сумма четных: ', sum);

// ----- Вариант-2 (логика от обратного)-------------

for (const number of numbers) {
  if (number % 2 !== 0) {
    // console.log('Эту итерацию нужно пропустить', number);
    continue;
  }
  // console.log(`${number} - четное число!`);
  sum += number;
}
console.log('сумма четных: ', sum);

// ----- Вариант-3 ----------------------------------

for (let i = 0; i < numbers.length; i += 1) {
  const number = numbers[i];

  if (number % 2 === 0) {
    console.log('четное: ', number);
    sum += number;
  }
}
console.log('сумма четных: ', sum);

// ----- Вариант-4 ----------------------------------

for (let i = 0; i < numbers.length; i += 1) {
  // console.log(numbers[i]);
  if (numbers[i] % 2 === 0) {
    console.log('четное: ', numbers[i]);
    sum += numbers[i];
  }
}
console.log('сумма четных: ', sum);

|============================
*/
// ________________________________________________________________________________________
// Задача-4
//  * Напиши скрипт поиска логина
//  * - Если логина нет, вывести сообщение 'Пользователь [логин] не найден.'
//  * - Если нашли логин, вывести сообщение 'Пользователь [логин] найден.'
//  * - Сначала через for
//  * - Потом через for...of
//  * - Логика break
//  * - Метод includes() с тернарным оператором

// const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
// const loginToFind = 'aj4xth3m4n';

// ===================================================
/** Решение Варианты includes() с тернарным оператором
|============================

// Этот метод логики называется дикларативный код. 
// Метод includes() под капотом делает переборку и сравнения. Называется Абстракция.

const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
const loginToFind = 'aj4xth3m4n';

const message = logins.includes(loginToFind)
  ? `Пользователь ${loginToFind} найден.`
  : `Пользователь ${loginToFind} не найден.`;

console.log(message);

|============================
*/
// ===================================================
/** Решение Варианты for of 
|============================

const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
const loginToFind = 'aj4xth3m4n';

// -------------------------------------------------------------------
// ----- Вариант for of - 1й вар. ------------------------------------

let message = '';

for (const login of logins) {
  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
  } else {
    message = `Пользователь ${loginToFind} не найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 2й вар. ------------------------------------

let message = '';

for (const login of logins) {
  if (login !== loginToFind) {
    message = `Пользователь ${loginToFind} не найден.`;
  } else {
    message = `Пользователь ${loginToFind} найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 3й вар. Логика break -----------------------

let message = `Пользователь ${loginToFind} не найден.`;

for (const login of logins) {
  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 4й вар. Логика break -----------------------

let message = '';

for (const login of logins) {
  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
  message = `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 5й вар. с тернарным оператором -------------

let message = '';

for (const login of logins) {
  message =
    login === loginToFind
      ? `Пользователь ${loginToFind} найден.`
      : `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

|============================
*/
// ===================================================
/** Решение Варианты for
|============================

const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
const loginToFind = 'aj4xth3m4n';

// -------------------------------------------------------------------
// ----- Варианты for - 1й вар. --------------------------------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login !== loginToFind) {
    message = `Пользователь ${loginToFind} не найден.`;
  } else {
    message = `Пользователь ${loginToFind} найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 2й вар. --------------------------------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
  } else {
    message = `Пользователь ${loginToFind} не найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 3й вар. Логикф break -------------------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
  message = `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 4й вар. Логика break -------------------------

let message = `Пользователь ${loginToFind} не найден.`;

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 5й вар. с тернарным оператором ---------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  message =
    login === loginToFind
      ? `Пользователь ${loginToFind} найден.`
      : `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

|============================
*/
// ===================================================
// ________________________________________________________________________________________
// Задача-5
//  * Напиши скрипт поиска самого маленького числа в массиве,
//  * при условии что числа уникальные(не повторяются).

// const numbers = [51, 18, 13, 24, 7, 85, 19];

/** Решение:
|============================

const numbers = [51, 18, 13, 24, 7, 85, 19];

// ----- Вариант Самое маленькое число ------------

let smallNumber = numbers[0];

for (const number of numbers) {
  if (number < smallNumber) {
    smallNumber = number;
  }
}

console.log(smallNumber);

// ----- Вариант Самое большое число---------------

let bigNumber = numbers[0];

for (const number of numbers) {
  if (number > bigNumber) {
    bigNumber = number;
  }
}

console.log(bigNumber);

|============================
*/
// ________________________________________________________________________________________
// Задача-6
//  * Напиши скрипт, который объединяет все элементы массива в одно строковое значение.
//  * Элементов может быть произвольное кол-во.
//  * Пусть элементы массива  в строке будут разделены запятой.
//  * - Сначала через for
//  * - Потом через join()

// const friends = ['Mango', 'Poly', 'Kiwi', 'Ajax'];

/** Решение:
|============================

// ----- Вариант-1 for of -------------------------

let string = '';

for (const friend of friends) {
  string += friend + ',';
}
string = string.slice(0, string.length - 1);

console.log(string);

// ----- Вариант-2 for ------------------------------

let string = '';

for (let i = 0; i < friends.length; i += 1) {
  const friend = friends[i];
  string += friend + ',';
}
string = string.slice(0, string.length - 1);
console.log(string);

// ----- Вариант-3 join() ---------------------------

const message = friends.join(',');

console.log(message);

|============================
*/
// ________________________________________________________________________________________
// Задача-7
// * Напиши скрипт который заменяет регистр каждого символа в строке на противоположный.
// * Например, если строка «JavaScript», то на выходе должена быть строка «jAVAsCRIPT».

// const string = 'JavaScript';

/** Решение:
|============================

const string = 'JavaScript';

// ----- Вариант-1 Решение современное с тернарным оператором ----------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  const isInLowerCase = letter === letter.toLowerCase();
  invertedString += isInLowerCase ? letter.toUpperCase() : letter.toLowerCase();
}
console.log(invertedString);

// ----- Вариант-2 Решение современное с тернарным оператором ----------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  invertedString +=
    letter === letter.toLowerCase()
      ? letter.toUpperCase()
      : letter.toLowerCase();
}
console.log(invertedString);

// ----- Вариант-3 Решение-Old shool if else --------------------------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  if (letter === letter.toUpperCase()) {
    invertedString += letter.toLowerCase();
  } else {
    invertedString += letter.toUpperCase();
  }
}
console.log(invertedString);

// ----- Вариант-4 Решение Непонятное с тернарным оператором ----------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  invertedString +=
    letter === letter.toLocaleLowerCase()
      ? (invertedString += letter.toLocaleUpperCase())
      : (invertedString += letter.toLocaleLowerCase());
}
console.log(invertedString);

|============================
*/
// ________________________________________________________________________________________
// Задача-8
//  * Делаем slug в URL из названия статьи (например на dev.to)
//  * Заголовок статьи состоит только из букв и пробелов
//  * - Нормализируем строку
//  * - Разбиваем по словам
//  * - Сшиваем в строку с разделителями
// Должно получиться top-10-benefits-of-react-framework

// const title = 'Top 10 benefits of React framework';

/** Решение:
|============================
const title = 'Top 10 benefits of React framework';

// ----- Вариант-1 Решение Решение современное (Метод чейнинг) ------

const slug = title.toLowerCase().split(' ').join('-');
console.log(slug);

// ----- Вариант-2 Решение-Old shool --------------------------------

const normilizedTitle = title.toLowerCase();
// console.log(normilizedTitle);

const words = normilizedTitle.split(' ');
// console.log(words);

const slug = words.join('-');
console.log(slug);

|============================
*/
// ________________________________________________________________________________________
// Задача-9
// * Напиши скрипт который считает сумму элементов двух массивов.

// const array1 = [5, 10, 15, 20];
// const array2 = [10, 20, 30];

/** Решение:
|============================
const array1 = [5, 10, 15, 20];
const array2 = [10, 20, 30];

// ----- Вариант-1 Хороший метод с .concat() -----------------------------------

let total = 0;

const numbers = array1.concat(array2);

for (const number of numbers) {
  total += number;
}
console.log(total);

// ----- Вариант-2 Плохой вариант, но рабочий ----------------------------------

let total = 0;

for (let i = 0; i < array1.length; i += 1) {
  total += array1[i];
}
for (let i = 0; i < array2.length; i += 1) {
  total += array2[i];
}
console.log(total);

|============================
*/
// ________________________________________________________________________________________
// Задача-10
//  * Работем с коллекцией карточек в trello
//  * - Метод splice()
//  * - Удалить четвертую карточку из масива.
//  * - Добавить 'Карточка-x' и 'Карточка-y' в середину масива на 3ю и 4ю позицию.
//  * - Обновить заменить 'Карточка-2' на 'Карточка-8' в масиве.

// const cards = [
//   'Карточка-1',
//   'Карточка-2',
//   'Карточка-3',
//   'Карточка-4',
//   'Карточка-5',
// ];
// console.table(cards);

/** Удаление, Добавление, Обнавление масива. Методы indexOf(), .splice()
|============================

const cards = [
  'Карточка-1',
  'Карточка-2',
  'Карточка-3',
  'Карточка-4',
  'Карточка-5',
];

console.table(cards);

// * Удаление (по индексу), метод indexOf()
// ----------------------------------------------------------------
const cardToRemove = 'Карточка-3';
const index = cards.indexOf(cardToRemove);
console.log(index);

cards.splice(index, 1);
console.table(cards);

// * Добавление (по индексу) метод .splice() в произвольном месте.
// ----------------------------------------------------------------
const cardToInsert = 'Карточка-6';
const index = 3;

cards.splice(3, 0, 5, 10, 20); // Пример

cards.splice(index, 0, cardToInsert);
console.table(cards);

// * Обновление (по индексу)
// ----------------------------------------------------------------
const cardToUpdate = 'Карточка-4';
const index = cards.indexOf(cardToUpdate);

console.log(index);
cards.splice(index, 1, 'Обновленная карточка-4');

console.table(cards);

|============================
*/
// ________________________________________________________________________________________________
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ================================================================================================
// Георг модуль-2 занятие 1 Масивы
// ================================================================================================
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ________________________________________________________________________________________________

// Example 1 - Базові операції з масивом
// Створіть масив genres з елементами «Jazz» та «Blues».
// Додайте «Рок-н-рол» до кінця.
// Виведіть у консоль перший елемент масиву.
// Виведіть у консоль останній елемент масиву. Код повинен працювати для масиву довільної довжини.
// Видаліть перший елемент та виведіть його в консоль.
// Вставте «Country» та «Reggae» на початок масиву.

// const genres = ;

/** Решение:
|============================

// Створіть масив genres.
const genres = [];
console.log(genres);

// -------------------------------

// Додайте до масиву genres елементи «Jazz» та «Blues».
genres.push('Jazz', 'Blues');
console.table(genres);

// -------------------------------

// Додайте «Рок-н-рол» до кінця.
genres.push('Рок-н-рол');
console.log(genres);

// -------------------------------

// Виведіть у консоль перший елемент масиву.
console.log(genres[0]);

const firstItem = genres[0];
console.log(firstItem);

// -------------------------------

// Виведіть у консоль останній елемент масиву. Код повинен працювати для масиву довільної довжини.
console.log(genres[genres.length - 1]);

const lastItem = genres[genres.length - 1];
console.log(lastItem);

// -------------------------------

// Видаліть перший елемент та виведіть його в консоль.
// Вариант-1
console.log(genres.splice(0, 1));
// Вариант-2
console.log(genres.shift());

// -------------------------------

// Вставте «Country» та «Reggae» на початок масиву.
// Вариант-1
genres.splice(0, 0, 'Country', 'Reggae');
console.log(genres);
// Вариант-2
genres.unshift('Country', 'Reggae');
console.log(genres);

|============================
*/
// ________________________________________________________________________________________
// Example 2 - Масиви та рядки
// Напиши скрипт для обчислення площі прямокутника зі сторонами, значення яких зберігаються у змінній values у вигляді рядка.
// Значення гарантовано розділені пробілом.

// const values = '8 11';

/** Решение:
|============================

const values = '8 11';

const numbersRectangle = values.split(' ');
const number1 = Number(numbersRectangle[0]);     // Вариант-1 (приведение к числу)
const number2 = parseInt(numbersRectangle[1]);   // Вариант-2 (приведение к числу)

const area = number1 * number2;
console.log(area);

|============================
*/
// ________________________________________________________________________________________

// Example 3 - Перебір масиву
// Напиши скрипт для перебору масиву fruits циклом for.
// Для кожного елемента масиву виведи в консоль рядок у форматі
// номер_елемента: значення_елемента.
// Нумерація елементів повинна починатися з 1.

// const fruits = ['🍎', '🍇', '🍑', '🍌', '🍋'];

/** Решение:
|============================

const fruits = ['🍎', '🍇', '🍑', '🍌', '🍋'];

// ----- Вариант-1 for of -----------------------------

let item = 0;
let message = '';

for (const fruit of fruits) {
  message = `${(item += 1)}: ${fruit}`;
  console.log(message);
}

// ----- Вариант-2 for --------------------------------

const fruits = ['🍎', '🍇', '🍑', '🍌', '🍋'];

let i = 1;

for (let i = 0; i < fruits.length; i += 1) {
  console.log(`${i + 1}: ${fruits[i]}`);
}

|============================
*/
// ________________________________________________________________________________________
// Example 4 - Масиви та цикли
// Напиши скрипт, який виводить у консоль ім'я та телефонний номер користувача.
// У змінних names та phones зберігаються рядки імен та телефонних номерів, розділені комами.
// Порядковий номер імен та телефонів у рядках вказують на відповідність.
// Кількість імен та телефонів гарантовано однакова.

// const names = 'Jacob,William,Solomon,Artemis';
// const phones = '89001234567,89001112233,890055566377,890055566300';

/** Решение:
|============================
// const names = 'Jacob,William,Solomon,Artemis';
// const phones = '89001234567,89001112233,890055566377,890055566300';

// Наши план
// 1) Преобразовать текст в масив.
// 2) Перебрать масив.
// 3) Создать шаблонный текст. `Jacob: 89001234567`

// Действие-1 Преобразовать текст в масив.
const namesArr = names.split(',');
// console.log(namesArr);
const phonesArr = phones.split(',');
// console.log(phonesArr);

// Действие-2 Перебрать масив.
for (let i = 0; i < namesArr.length; i += 1) {
  // console.log(namesArr[i]);
  // console.log(phonesArr[i]);

  // Действие-3 Создаём шаблонный текст. `Jacob: 89001234567`.
  console.log(`${namesArr[i]}: ${phonesArr[i]}`);
}

|============================
*/
// ________________________________________________________________________________________
// Example 5 - Масиви та рядки
// Напиши скрипт, який виводить у консоль усі слова рядка крім першого і останнього.
// Результуючий рядок не повинен починатися або закінчуватися символ пробілу.
// Скрипт повинен працювати для будь - якого рядка.

// const string = 'Welcome to the future';

/** Решение:
|============================
const string = 'Welcome to the future';

// Наши план
// 1) Преобразовать текст в масив.
// 2) Удалить первый элемент масива.
// 3) Удалить последний элемент масива.
// 4) Преобразовать масив в тект.

const wordsArr = string.split(' ');        // 1 Преобразовать текст в масив.
wordsArr.shift();                          // 2 Удалить первый элемент масива.
wordsArr.pop();                            // 3 Удалить последний элемент масива.
const newString = wordsArr.join(' ');      // 4 Преобразовать масив в тект.

console.log(newString);

console.log(`"${newString}"`);             // Для проверки, что в начале и в конце нет пробелов, ставим "".
|============================
*/
// ________________________________________________________________________________________
// Example 6 - Масиви та рядки
// Напиши скрипт, який «розгортає» рядок (зворотний порядок букв) і виводить його в консоль.

// const string = 'Welcome to the future';

/** Решение:
|============================

const string = 'Welcome to the future';

// Наши план
// 1) Преобразовать текст в масив букв.
// 2) Перевернуть текст.
//    (Вар - 1[1, 2, 3].reverse());
//    (Вар - 2 пройтись по масиву циклом и в новый пустой масив закинуть по одной букве в нужном нам порядке.);
// 3) Снова масив преобразовать в текст.

// ---------------------------------------------------
// ----- Вариант-1  легкое решение (чейнинг) ---------

const reversedString = string.split('').reverse().join('');

console.log(reversedString);

// ---------------------------------------------------
// ----- Вариант-2  легкое решение -------------------

const letters = string.split('');                   // 1 Преобразовать текст в масив букв.
const reversedLetter = letters.reverse();           // 2 Перевернуть текст.
const reversedString = reversedLetter.join('');     // 3 Снова масив преобразовать в текст.

console.log(reversedString);

// ---------------------------------------------------
// ----- Вариант-3 цикл for of -----------------------

// Преобразовать текст в масив букв.
// Перевернуть текст. Для этого создаем пустой масив.
// Проходим циклом for of по символам масива.
// Добавляем буквы в новый пустой масив.
// Снова масив преобразовать в текст.


const letters = string.split('');
const reversedLetter = [];

for (const letter of letters) {
  reversedLetter.unshift(letter);
}

const reversedString = reversedLetter.join('');

console.log(reversedString);

|============================
*/
// ________________________________________________________________________________________
// Example 8 - Пошук елемента
// Напиши скрипт пошуку найменшого числа у масиві.
// Код повинен працювати для будь - якого масиву чисел.
// Використовуй цикл для розв'язання задачі.

// const numbers = [2, 17, 94, 1, 23, 37];
// let min;
// console.log(min); // 1

/** Решение:
|============================
// const numbers = [2, 17, 94, 1, 23, 37];
// let min;
// console.log(min); // 1

// ----- Вариант-1  for of ---------------------------

const numbers = [2, 17, 94, 1, 23, 37];
let min = numbers[0];
console.log(min); // 1

for (const number of numbers) {
  if (number < min) {
    min = number;
  }
}
console.log(min);


// ----- Вариант-2  for ------------------------------

const numbers = [2, 17, 94, 1, 23, 37];
let min = numbers[0];

for (let i = 0; i < numbers.length; i += 1) {
  if (min > numbers[i]) {
    min = numbers[i];
  }
}
console.log(min); // 1

// ----- Вариант-3 -----------------------------------

const numbers = [2, 17, 94, 1, 23, 37];
let min;
console.log(Math.min(2, 17, 94, 1, 23, 37)); // 1


|============================
*/
// ________________________________________________________________________________________
// Example 7 - (4й модуль) Сортування масиву із циклом
// Напиши скрипт сортування масиву рядків в алфавітному порядку за першою літерою елемента.

// const langs = ['python', 'javascript', 'c++', 'haskel', 'php', 'ruby'];

/** Решение:
|============================

langs.sort(function (a, b) {
  const letter1 = a[0];
  const letter2 = b[0];

  return letter1.localeCompare(letter2);
});

console.log(langs);

|============================
*/
// ________________________________________________________________________________________

/** В чем отличия i++ и i += ??????
|============================

// ----- i++ (post increment) vs i += 1 vs ++i (pre increment) -----
let x = 1;

console.log((x += 1)); // 2
console.log((x += 1)); // 3
console.log((x += 1)); // 4
console.log((x += 1)); // 5
console.log(x); // 5

let y = 1;

console.log(y++); // 1
console.log(y++); // 2
console.log(y++); // 3
console.log(y++); // 4
console.log(y); // 5

let q = 1;

console.log(++q); // 2
console.log(++q); // 3
console.log(++q); // 4
console.log(++q); // 5
console.log(q); // 5

|============================
*/

// ________________________________________________________________________________________________
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ================================================================================================
// Репета модуль-2 занятие 2 Функции
// ================================================================================================
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ________________________________________________________________________________________________

/** * Функции
|============================

//  * Функции
//  * - Функциональные выражения
//  * - Аргументы и параметры
//  * - Возврат значения

const add = function (x, y) {
  // console.log(x);
  // console.log(y);
  // console.log('Выполянется функция add');

  return x + y;
};

// Варианты вызова функции.
add(10, 15);
add(30, 50);
console.log(add(10, 15)); // Это не вызов функции. Это мы логируем результат работы функции.
console.log(add);         // Это логирование функции.

const r1 = add(5, 3);
console.log('r1: ', r1);

const r2 = add(10, 15);
console.log('r2: ', r2);

const r3 = add(30, 50);
console.log('r3: ', r3);

// --------------------------------------------
// Ключевое слово return

const fn = function (value) {
  console.log(1);
  console.log(2);

  if (value < 50) {
    return 'Меньше чем 50';
  }
  return 'Больше чем 50';
};

console.log('Результат функции: ', fn(10));

console.log('Результат функции: ', fn(1000));

// --------------------------------------------

* - Стек вызовов 
* - Stack trace и поиск ошибок

const fnA = function () {
  console.log('Выполняется функция A');
};

const fnB = function () {
  console.log('Выполняется функция B');
};

const fnC = function () {
  console.log('Выполняется функция C');
};

// console.log('Лог перед вызовом функции A');

fnA();

// console.log('Лог после вызова функции A');

// console.log('Лог перед вызовом функции B');
fnB();
// console.log('Лог после вызова функции B');

// console.log('Лог перед вызовом функции C');
fnC();
// console.log('Лог после вызова функции C');

// --------------------------------------------

* - Отлавливаем ошибки в функциях

const fnA = function () {
  console.log('Выполняется функция A');
  fnB();
};

const fnB = function () {
  console.log('Выполняется функция B');
  fnC();
};

const fnC = function () {
  console.log('Выполняется функция C');
  console.log(value);
};

// console.log('Лог перед вызовом функции A');

fnA();

|============================
*/
// ________________________________________________________________________________________
// Задача-2:
//  * Напиши функцию calculateTotalPrice(items)
//  * которая принимает массив цен (чисел) и возвращает их сумму
// ----------------------------
// const result = calculateTotalPrice([1, 2, 3]);
// console.log(`Общая сумма покупок ${result}`); // 6

// console.log(calculateTotalPrice([5, 10, 15, 20])); // 50
// console.log(calculateTotalPrice([100, 200, 300])); // 600
// ----------------------------
/** С прошлого урока задача-1
|============================

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];
let total = 0;

for (const value of cart) {
  total += value;
}

console.log('Total: ', total);

|============================
*/
// ----------------------------
/** Решение:
|============================

const calculateTotalPrice = function (items) {
  console.log('items внутри функции: ', items);

  let total = 0;

  for (const item of items) {
    total += item;
  }

  return total;
};

const r1 = calculateTotalPrice([1, 2, 3]);

console.log(`Общая сумма покупок ${r1}`); // 6
console.log(calculateTotalPrice([5, 10, 15, 20])); // 50
console.log(calculateTotalPrice([100, 200, 300])); // 600

|============================
*/
// ________________________________________________________________________________________
// Задача-3:
// * Напиши функцию logItems(items) для перебора и логирования массива
// Эта функция ничего назад не возвращает.
// ----------------------------
// logItems(['Mango', 'Kiwi', 'Poly', 'Ajax']);
// logItems([1, 2, 3, 4, 5]);
// logItems(['клавиатура', 'наушники', 'часы']);
// ----------------------------
/** Решение:
|============================

const logItems = function (items) {
  for (const item of items) {
    console.log(item);
  }
};

logItems(['Mango', 'Kiwi', 'Poly', 'Ajax']);
logItems([1, 2, 3, 4, 5]);
logItems(['клавиатура', 'наушники', 'часы']);

|============================
*/
// ________________________________________________________________________________________
// Задача-4:
//  * Напиши функцию findLogin(allLogins, login) для поиска логина
//  * - Если логина нет, вывести сообщение 'Пользователь [логин] не найден.'
//  * - Если нашли логин, вывести сообщение 'Пользователь [логин] найден.'
// ----------------------------
// const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];

// console.log(findLogin(logins, 'avocod3r'));
// console.log(findLogin(logins, 'k1widab3st'));
// console.log(findLogin(logins, 'jam4l'));
// console.log(findLogin(logins, 'poly1scute'));

// ----------------------------
/** С прошлого урока задача-4
|============================

const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];

const loginToFind = 'aj4xth3m4n';

const message = logins.includes(loginToFind)
  ? `Пользователь ${loginToFind} найден.`
  : `Пользователь ${loginToFind} не найден.`;

  console.log(message);

|============================
*/
// ----------------------------
/** Решение:
|============================

// Вариант-1 (тернарный оператор - правильный вариант)---

const findLogin = function (allLogins, loginToFind) {
  return allLogins.includes(loginToFind)
    ? `Пользователь ${loginToFind} найден.`
    : `Пользователь ${loginToFind} не найден.`;
};

// Вариант-2 (тернарный оператор - правильный вариант)---

const findLogin = function (allLogins, loginToFind) {
  const message = allLogins.includes(loginToFind)
    ? `Пользователь ${loginToFind} найден.`
    : `Пользователь ${loginToFind} не найден.`;

  return message;
};

// Вариант-3 (for of - правильный вариант)---------------

const findLogin = function (allLogins, loginToFind) {
  for (const login of allLogins) {
    if (login === loginToFind) {
      return `Пользователь ${loginToFind} найден.`;
    }
  }

  return `Пользователь ${loginToFind} не найден.`;
};

// Вариант-4 (for of - как пример) ----------------------

const findLogin = function (allLogins, loginToFind) {
  let message = `Пользователь ${loginToFind} не найден.`;

  for (const login of allLogins) {
    if (login === loginToFind) {
      message = `Пользователь ${loginToFind} найден.`;
    }
  }
  return message;
};

// ---------------------------------------------
console.log(findLogin(logins, 'avocod3r'));
console.log(findLogin(logins, 'k1widab3st'));
console.log(findLogin(logins, 'jam4l'));
console.log(findLogin(logins, 'poly1scute'));

|============================
*/
// ________________________________________________________________________________________
// Задача-5:
//  * Напиши функцию findSmallesNumber(numbers) для поиска самого маленького числа в массиве,
//  * при условии что числа уникальные (не повторяются).
// ----------------------------
// console.log(findSmallesNumber([3, 8, 12, -2, 15])); // -2
// console.log(findSmallesNumber([100, 54, 8, 12, 47])); // 8
// console.log(findSmallesNumber([7, 21, 84, 15, 4])); // 4
// ----------------------------
/** С прошлого урока задача-5
|============================

const numbers = [51, 18, 13, 24, 7, 85, 19];

let smallNumber = numbers[0];

for (const number of numbers) {
  if (number < smallNumber) {
    smallNumber = number;
  }
}

|============================
*/
// ----------------------------
/** Решение:
|============================

const findSmallesNumber = function (numbers) {
  let smallestNumber = numbers[0];

  for (const number of numbers) {
    if (number < smallestNumber) {
      smallestNumber = number;
    }
  }

  return smallestNumber;
};

console.log(findSmallesNumber([3, 8, 12, -2, 15])); // -2
console.log(findSmallesNumber([100, 54, 8, 12, 47])); // 8
console.log(findSmallesNumber([7, 21, 84, 15, 4])); // 4

|============================
*/
// ________________________________________________________________________________________
// Задача-6:
//  * Напиши функцию changeCase(string) которая заменяет регистр
//  * каждого символа в строке на противоположный.
//  * Например, если строка «JavaScript», то на выходе должена быть строка «jAVAsCRIPT».

// console.log(changeCase('JavaScript')); // jAVAsCRIPT
// console.log(changeCase('qweRTY')); // QWErty
// console.log(changeCase('mAnGo')); // MaNgO
// console.log(changeCase('AjAx')); // aJaX

// ----------------------------
/** С прошлого урока задача-7 :
|============================
const string = 'JavaScript';

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  const isInLowerCase = letter === letter.toLowerCase();
  invertedString += isInLowerCase ? letter.toUpperCase() : letter.toLowerCase();
}
console.log(invertedString);
|============================
*/
// ----------------------------
/** Решение:
|============================
// Вариант-1 с тернарным оператором
// ________________________________

const changeCase = function (string) {
  const letters = string.split('');
  let invertedString = '';

  for (const letter of letters) {
    const isInLowerCase = letter === letter.toLowerCase();

    invertedString += isInLowerCase
      ? letter.toUpperCase()
      : letter.toLowerCase();
  }

  return invertedString;
};

// Вариант-2 if else
// _________________________________

const changeCase = function (string) {
  const letters = string.split('');
  let invertedString = '';

  for (const letter of letters) {
    if (letter === letter.toLowerCase()) {
      invertedString += letter.toUpperCase();
    } else {
      invertedString += letter.toLowerCase();
    }
  }
  return invertedString;
};

// ---------------------------------------------
console.log(changeCase('qweRTY')); // QWErty
console.log(changeCase('mAnGo')); // MaNgO
console.log(changeCase('AjAx')); // aJaX

|============================
*/
// ________________________________________________________________________________________
// Задача-7:
//  * Напиши функцию slugify(string) которая получает строку и возвращает URL-slug
//  * Строка состоит только из букв и пробелов
// -----------------------------------------------------------
// console.log(slugify('Top 10 benefits of React framework'));
// console.log(slugify('Azure Static Web Apps are Awesome'));
// console.log(slugify('Technical writing tips for non-native English speakers'));

// ----------------------------
/** С прошлого урока задача-8 :
|============================
const title = 'Top 10 benefits of React framework';

const normilizedTitle = title.toLowerCase();
const words = normilizedTitle.split(' ');
const slug = words.join('-');

// const slug = title.toLowerCase().split(' ').join('-'); //Вариант-2

console.log(slug);
|============================
*/
// ----------------------------

/** Решение:
|============================

// Вариант-1 --------------------------------------
const slugify = function (string) {
  return string.toLowerCase().split(' ').join('-');
};

// Вариант-2 --------------------------------------
const slugify = function (string) {
  const normalizedString = string.toLowerCase();
  const words = normalizedString.split(' ');
  const slug = words.join('-');
  return slug;
};

// -----------------------------------------------------------
console.log(slugify('Top 10 benefits of React framework'));
console.log(slugify('Azure Static Web Apps are Awesome'));
console.log(slugify('Technical writing tips for non-native English speakers'));

|============================
*/
// ________________________________________________________________________________________
// Задача:
// * Псевдомассив arguments и Array.from и ...
// =====================================
/** Псевдо масив и (операция ...rest)
|============================

//  Это метод Современный-------------------

const fn = function (a, b, c, ...args) {
  console.log(`${a} ${b} ${c}`);
  console.log(args);
};

fn('hello', 1, 2, 3);
fn('aloha', 1, 2, 3, 4, 5);
fn('hi', 1, 2, 3, 4, 5, 6, 7);
// ----------------------------


//  Это метод Old Shool -------------------

const fn = function () {
  console.log(arguments);

  const args = Array.from(arguments);

  console.log(args);
};

fn(1, 2, 3);
fn(1, 2, 3, 4, 5);
fn(1, 2, 3, 4, 5, 6, 7);

|============================
*/
// =====================================
// Задача-8:
//  * Напиши функцию add для сложения произвольного количества аргументов (чисел)
//  * - Операция ... (rest)
// ----------------------------
/** Решение:
|============================

const add = function (...args) {
  console.log(args);
  let total = 0;

  for (const arg of args) {
    total += arg;
  }

  return total;
};

console.log(add(1, 2, 3));
console.log(add(1, 2, 4, 5, 6));

|============================
*/
// ________________________________________________________________________________________
// Задача-9:
// * Напиши функцию filterNumbers(array [, number1, ...]) которая:
//  * - первым аргументом принимает массив чисел
//  * - после первого аргумента может быть произвольное количество других аргументов которые будут числами.
//  * - Функция должна вернуть новый массив, в котором будут только те аргументы, начиная со второго,
//  *   для которых есть аналог в оригинальном массиве.
// ----------------------------
/** Решение:
|============================

const filterNumbers = function (array, ...args) {
  console.log('array: ', array);
  console.log('args: ', args);
  const uniqueElements = [];

  for (const element of array) {
    if (args.includes(element)) {
      uniqueElements.push(element);

      console.log(`${element} есть везде!`);
    }
  }

  return uniqueElements;
};

console.log(filterNumbers([1, 2, 3, 4, 5], 10, 15, 2, 3, 8)); // [2, 3]
console.log(filterNumbers([10, 15, 25, 30], 23, 30, 18, 15)); // [30, 15]
console.log(filterNumbers([100, 200, 300, 400, 500], 7, 12, 200, 64)); // [200]

|============================
*/
// ________________________________________________________________________________________________
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ================================================================================================
// Георг модуль-2 занятие 2 Функции
// ================================================================================================
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// ________________________________________________________________________________________________
// Example 1 - Индекс массы тела
// Напиши функцию calcBMI(weight, height) которая рассчитывает и возвращает индекс массы тела человека.
// Для этого необходимо разделить вес в киллограммах на квадрат высоты человека в метрах.
// Вес и высота будут специально переданы как строки.
// Нецелые числа могут быть заданы в виде 24.7 или 24, 7, то есть в качестве разделителя дробной части может быть запятая.
// Индекс массы тела необходимо округлить до одной цифры после запятой;

// const bmi = calcBMI('88,3', '1.75');
// console.log(bmi); // 28.8

/** Решение:
|============================
const bmi = calcBMI('88,3', '1.75');

function calcBMI(weight, height) {
  const numWeight = parseFloat(weight.replace(',', '.'));
  const numHeight = parseFloat(height.replace(',', '.'));
  const bmi = numWeight / Math.pow(numHeight, 2);

  return parseFloat(bmi.toFixed(1));
}

console.log(bmi); // 28.8
|============================
*/
// ________________________________________________________________________________________
// Example 2 - Меньшее из чисел
// Напиши функцию min(a,b), которая возвращает меньшее из чисел a и b.

// console.log(min(2, 5)); // 2
// console.log(min(3, -1)); // -1
// console.log(min(1, 1)); // 1

/** Решение:
|============================
Вариант-1 стрелочная функция -------------------

const min = (a, b) => {
  return a < b ? a : b;
};

Вариант-2 Math.min() ---------------------------

function min(a, b) {
  return Math.min(a, b);
}

Вариант-3 тернарный оператор -------------------

function min(a, b) {
  return a < b ? a : b;
}

Вариант-4 if -----------------------------------

function min(a, b) {
  if (a < b) {
    return a;
  }
  return b;
}

// --------------------------
console.log(min(2, 5)); // 2
console.log(min(3, -1)); // -1
console.log(min(1, 1)); // 1

|============================
*/
// ________________________________________________________________________________________
// Example 3 - Площадь прямоугольника
// Напиши функцию getRectArea(dimensions) для вычисления площади прямоугольника со сторонами,
// значения которых будут переданы в параметр dimensions в виде строки.
// Значения гарантированно разделены пробелом.

// function getRectArea(dimensions) {}

// console.log(getRectArea('8 11'));

/** Решение:
|============================
Вариант-1 --------------------------

function getRectArea(dimensions) {
  const numbers = dimensions.split(' ');
  const a = Number(numbers[0]);
  const b = Number(numbers[1]);

  return a * b;
}

Вариант-2 --------------------------

function getRectArea(dimensions) {
  const numbers = dimensions.split(' ');
  const a = numbers[0];
  const b = numbers[1];

  return Number(a) * Number(b);
}

Вариант-3  Через константу ----------

function getRectArea(dimensions) {
  const numbers = dimensions.split(' ');
  const [a, b] = numbers;

  return Number(a) * Number(b);
}

// ---------------------------------

console.log(getRectArea('8 11'));

|============================
*/
// ________________________________________________________________________________________
// Example 4 - Логирование элементов
// Напиши функцию logItems(items), которая получает массив и использует цикл for,
// который для каждого элемента массива будет выводить в консоль сообщение в формате < номер элемента > - <значение элемента>.
// Нумерация элементов должна начинаться с 1.
// Например для первого элемента массива ['Mango', 'Poly', 'Ajax'] с индексом 0 будет выведено 1 - Mango,
// а для индекса 2 выведет 3 - Ajax.

// function logItems(items) {}

// logItems(['Mango', 'Poly', 'Ajax']);
// logItems(['🍎', '🍇', '🍑', '🍌', '🍋']);

/** Решение:
|============================

function logItems(items) {
  console.log('---------------------');
  for (let i = 0; i < items.length; i += 1) {
    console.log(`${i + 1}: ${items[i]}`);
  }
}

logItems(['Mango', 'Poly', 'Ajax']);
logItems(['🍎', '🍇', '🍑', '🍌', '🍋']);

|============================
*/
// ________________________________________________________________________________________
// Example 5 - Логирование контактов
// Напиши функцию printContactsInfo(names, phones) которая выводит в консоль имя и телефонный номер пользователя.
// В параметры names и phones будут переданы строки имен и телефонных номеров, разделенные запятыми.
// Порядковый номер имен и телефонов в строках указывают на соответствие.
// Количество имен и телефонов гарантированно одинаковое.

// function printContactsInfo(names, phones) {}

// printContactsInfo(
//   'Jacob,William,Solomon,Artemis',
//   '89001234567,89001112233,890055566377,890055566300'
// );

/** Решение:
|============================
function printContactsInfo(names, phones) {
  const namesArr = names.split(',');
  const phonesArr = phones.split(',');

  for (let i = 0; i < namesArr.length; i += 1) {
    console.log(`${namesArr[i]}: ${phonesArr[i]}`);
  }
}
// ----------------------------------------------
printContactsInfo(
  'Jacob,William,Solomon,Artemis',
  '89001234567,89001112233,890055566377,890055566300'
);
|============================
*/
// ________________________________________________________________________________________
// Example 6 - Поиск наибольшего элемента
// Напиши функцию findLargestNumber(numbers)которая ищет самое большое число в массиве.

// function findLargestNumber(numbers) {}

// console.log(findLargestNumber([2, 17, 94, 1, 23, 37])); // 94
// console.log(findLargestNumber([49, 4, 7, 83, 12])); // 83

/** Решение:
|============================

Вариант-1 --------------------------

function findLargestNumber(numbers) {
  return Math.max(...numbers);
}

Вариант-2 --------------------------

function findLargestNumber(numbers) {
  let max = numbers[0];

  for (const number of numbers) {
    if (number > max) {
      max = number;
    }
  }
  return max;
}

Вариант-3 --------------------------

function findLargestNumber(numbers) {
  let max = numbers[0];

  for (let i = 0; i < numbers.length; i += 1) {
    if (numbers[i] > max) {
      max = numbers[i];
    }
  }
  return max;
}

// -----------------------------------------
console.log(findLargestNumber([2, 17, 94, 1, 23, 37])); // 94
console.log(findLargestNumber([49, 4, 7, 83, 12])); // 83
|============================
*/
// ________________________________________________________________________________________
// Example 7 - Среднее значение
// Напишите функцию calAverage()
// которая принимает произвольное кол-во аргументов и возвращает их среднее значение.
// Все аругменты будут только числами.

// function calAverage() {}

// console.log(calAverage(1, 2, 3, 4)); // 2.5
// console.log(calAverage(14, 8, 2)); // 8
// console.log(calAverage(27, 43, 2, 8, 36)); // 23.2

/** Решение:
|============================

function calAverage() {
  let sum = 0;

  for (const number of arguments) {
    sum += number;
  }
  return sum / arguments.length;
}
// -------------------------------------------------
console.log(calAverage(1, 2, 3, 4)); // 2.5
console.log(calAverage(14, 8, 2)); // 8
console.log(calAverage(27, 43, 2, 8, 36)); // 23.2
|============================
*/
// ________________________________________________________________________________________
// Example 8 - Форматирование времени
// Напиши функцию formatTime(minutes)
// которая переведёт значение minutes(количество минут)
// в строку в формате часов и минут HH: MM.

// const hours = Math.floor(totalMinutes / 60);
// const minutes = totalMinutes % 60;
// console.log(hours);
// console.log(minutes);

// const doubleDigitHours = String(hours).padStart(2, 0);
// const doubleDigitMinutes = String(minutes).padStart(2, 0);
// console.log(`${doubleDigitHours}:${doubleDigitMinutes}`);

// function formatTime(minutes) {}

// console.log(formatTime(70)); // "01:10"
// console.log(formatTime(450)); // "07:30"
// console.log(formatTime(1441)); // "24:01"

/** Решение: 
|============================
// Решение Георг с нуля ---------------------------

function formatTime(minutesInput) {
  const hours = Math.floor(minutesInput / 60);
  const minutes = minutesInput % 60;

  const formattedHours = String(hours).padStart(2, 0);
  const formattedMinutes = String(minutes).padStart(2, 0);

  return `${formattedHours}:${formattedMinutes}`;
}

// ------------------------------
console.log(formatTime(70)); // "01:10"
console.log(formatTime(450)); // "07:30"
console.log(formatTime(1441)); // "24:01"

|============================
*/
// ________________________________________________________________________________________
// Example 9 - Коллекция курсов (includes, indexOf, push и т. д.)
// Напишите функции для работы с коллекцией обучающих курсов courses:
// * addCourse(name) - добавляет курс в конец коллекции
// * removeCourse(name) - удаляет курс из коллекции
// * updateCourse(oldName, newName) - изменяет имя на новое

// const courses = ['HTML', 'CSS', 'JavaScript', 'React', 'PostgreSQL'];

// addCourse('Express');
// console.log(courses); // ['HTML', 'CSS', 'JavaScript', 'React', 'PostgreSQL', 'Express']
// addCourse('CSS'); // 'У вас уже есть такой курс'

// removeCourse('React');
// console.log(courses); // ['HTML', 'CSS', 'JavaScript', 'PostgreSQL', 'Express']
// removeCourse('Vue'); // 'Курс с таким имененем не найден'

// updateCourse('Express', 'NestJS');
// console.log(courses); // ['HTML', 'CSS', 'JavaScript', 'PostgreSQL', 'NestJS']
// updateCourse('Express', 'NestJS');

/** Решение:
|============================

const courses = ['HTML', 'CSS', 'JavaScript', 'React', 'PostgreSQL'];
// -----------------------------------------------
const addCourse = name => {
  if (courses.includes(name)) {
    console.log(`У вас уже есть курс ${name}`);
    return;
  }
  courses.push(name);
};
// -----------------------------------------------
const removeCourse = name => {
  if (!courses.includes(name)) {
    console.log(`Курс с именем ${name} не найден`);
    return;
  }
  const index = courses.indexOf(name);
  courses.splice(index, 1);
};
// -----------------------------------------------
const updateCourse = (oldName, newName) => {
  if (!courses.includes(oldName)) {
    console.log(`Курс с именем ${oldName} не найден`);
    return;
  }
  const index = courses.indexOf(oldName);
  courses.splice(index, 1, newName);
};
// -----------------------------------------------
addCourse('Express');
console.log(courses); // ['HTML', 'CSS', 'JavaScript', 'React', 'PostgreSQL', 'Express']
addCourse('CSS'); // 'У вас уже есть такой курс'

removeCourse('React');
console.log(courses); // ['HTML', 'CSS', 'JavaScript', 'PostgreSQL', 'Express']
removeCourse('Vue'); // 'Курс с таким имененем не найден'

updateCourse('Express', 'NestJS');
console.log(courses); // ['HTML', 'CSS', 'JavaScript', 'PostgreSQL', 'NestJS']
|============================
*/
// ________________________________________________________________________________________
