// МАСИВЫ
//=======================================================================
/** Створення масиву
|============================

// Масив оголошується і береться у квадратні дужки[] - літералом масиву.
// Всередині дужок кожен елемент масиву розділяється комою.

const clients = ["Mango", "Poly", "Ajax"];

|============================
*/
// ______________________________________________________________________
/** Доступ до елементів
|============================

// Для доступу до значення елемента масиву використовується синтаксис квадратних дужок масив[індекс].
// Між іменем змінної, що зберігає масив, і квадратними дужками не повинно бути пробілу.

const clients = ["Mango", "Poly", "Ajax"];

Зазначаючи в дужках індекс елемента, ми отримуємо його значення
console.log(clients[0]); // Mango
console.log(clients[1]); // Poly
console.log(clients[2]); // Ajax

|============================
*/
// ______________________________________________________________________
/** Перевизначення
|============================

// На відміну від рядків, елементи масиву можна змінювати, звернувшись до них за індексом і присвоївши інше значення.

const clients = ['Mango', 'Poly', 'Ajax'];
clients[0] = 'Kiwi';
clients[1] = 'Pango';
console.log(clients); // ["Kiwi", "Pango", "Ajax"]

|============================
*/
// ______________________________________________________________________
/** Довжина масиву
|============================

// Довжина масиву, тобто кількість його елементів, зберігається у властивості length.
// Це динамічна величина, яка змінюється автоматично під час додавання або видалення елементів.

const clients = ["Mango", "Poly", "Ajax"];
console.log(clients.length); // 3

|============================
*/
// ______________________________________________________________________
/** Індекс останнього елемента
|============================

// Найчастіше, ми заздалегідь не знаємо яка буде довжина масиву в коді.
// Для того, щоб отримати значення останнього елемента, застосовується наступний підхід
// - довжина масиву завжди на одиницю більша, ніж індекс останнього елемента.
// Використовуючи формулу довжина_масиву - 1, можна отримати значення останнього елемента масиву довільної довжини.

const clients = ["Mango", "Poly", "Ajax"];
const lastElementIndex = clients.length - 1;
console.log(lastElementIndex); // 2
console.log(clients[lastElementIndex]); // "Ajax"

|============================
*/
// ______________________________________________________________________
/** Цикл for
|============================

// Цикл for можна використовувати для ітерації по масиву, тобто «перебрати» його поелементно.

const clients = ['Mango', 'Ajax', 'Poly'];

for (let i = 0; i < clients.length; i += 1) {
  console.log(clients[i]); // Mango Ajax Poly
}

// Для доступу до елементів використовується синтаксис квадратних дужок масив[індекс],
// де індекс - це значення лічильника циклу від 0 і до останнього індексу масиву,
// тобто менше, але не дорівнює його довжині.

|============================
*/
// ______________________________________________________________________
/** Цикл for...of
|============================

// Конструкція for...of оголошує цикл, що перебирає ітерабельні об'єкти, як-от масиви і рядки.
// Тіло циклу буде виконуватися для значення кожного елемента.
// Це хороша заміна циклу for, якщо не потрібен доступ до лічильника ітерації.

for (const variable of iterable) {
  // тіло циклу
}

// variable — змінна, яка буде зберігати значення елемента на кожній ітерації.
// iterable — колекція, яка містить ітерабельні (що можна порахувати) елементи, наприклад масив.

const clients = ['Mango', 'Ajax', 'Poly'];

for (const client of clients) {
  console.log(client);
}

const string = 'javascript';

for (const character of string) {
  console.log(character);
}

|============================
*/
// ______________________________________________________________________
/** Оператори break і continue
|============================

// Будемо шукати ім'я клієнта в масиві імен, 
// якщо знайшли - перериваємо цикл, оскільки немає сенсу шукати далі, імена у нас унікальні.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message;

for (const client of clients) {
  // На кожній ітерації будемо перевіряти чи збігається елемент масиву з іменем клієнта. 
  // Якщо збігається - записуємо в message повідомлення про успіх і робимо break, щоб далі не шукати.

  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }

  // Якщо вони не збігаються - записуємо в message повідомлення про відсутність імені.

  message = "Клієнт з таким ім'ям відсутній в базі даних!";
}

console.log(message); // "Клієнт з таким ім'ям є в базі даних!"

// ------------------

// Можна на початку задати message значення невдачі пошуку, а в циклі перезаписати його на успіх, якщо знайшли ім'я.
// Але break все одно нам знадобиться, оскільки, якщо у нас масив із 10000 клієнтів, а потрібний нам знаходиться на 2 позиції,
// то немає абсолютно жодного сенсу перебирати інші 9998 елементи.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message = "Клієнт з таким ім'ям відсутній в базі даних!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }
  // Якщо не збігається, то на цій ітерації нічого не робимо
}

console.log(message); // Клієнт з таким ім'ям є в базі даних!

|============================
*/
// ______________________________________________________________________
/** Використовуємо цикл для виведення тільки чисел, більших за певне значення.
|============================

const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
const threshold = 15;

// // Для чисел, менших ніж порогове значення, спрацьовує continue, виконання тіла
// // припиняється і управління передається на наступну ітерацію.

for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }

  console.log(`Число більше за ${threshold}: ${numbers[i]}`); // 18, 29, 34
}

|============================
*/
// ______________________________________________________________________
/** Присвоєння за посиланням і за значенням
|============================

// Фундаментальною відмінністю складних типів від примітивів є те, як вони зберігаються і копіюються.
// Примітиви: рядки, числа, булі, null і undefined, під час присвоєння повністю копіюються за значенням(by value).

// Зі складними типами - все по-іншому.
// У змінній, якій присвоєно масив або об'єкт, зберігається не саме значення,
// а адреса його місця в пам'яті, іншими словами - посилання(вказівник) на нього і вони передаються за посиланням(by reference).

// Уявімо змінну у вигляді аркушу паперу. Її значення ми уявимо як запис на цьому аркуші.

// Якщо ми захочемо повідомити зміст цього запису користувачам,
// то можемо це зробити наступним чином - зробити фізичні копії і вручити кожному,
// тобто зробити багато незалежних копій(присвоєння за значенням).

// Або покласти аркуш в зачиненій кімнаті і дати користувачам ключ від цієї кімнати,
// тобто один екземпляр із загальним доступом(присвоєння за посиланням).

// Тепер змінимо дані на аркуші паперу - значення змінної.
// Очевидно, що відвідувачі кімнати завжди будуть бачити зміни, які ми вносимо, оскільки змінюється оригінал і вони мають до нього доступ.
// І також очевидно, що власники паперових копій не помітять змін, дивлячись на свої копії.

// За умови передачі за значенням, змінним виділяється нова комірка пам'яті і в неї копіюються дані.
// Аналогія з багатьма копіями паперового аркушу має цілком реальне втілення, окремий аркуш для кожної копії.

// За умови передачі за посиланням, замість створення нового об'єкта, змінній присвоюється посилання (вказівник) на вже існуючий об'єкт,
// тобто на його місце в пам'яті.
// Таким чином, декілька змінних можуть вказувати на один і той самий об'єкт,
// за аналогією із закритою кімнатою, вони мають ключ доступу до оригіналу аркушу.

// Усі примітивні типи присвоюються за значенням, тобто створюється копія.

let a = 5;
// Присвоєння за значенням, в пам'яті буде створена ще
// одна комірка, в яку буде скопійоване значення 5
let b = a;
console.log(a); // 5
console.log(b); // 5

// Змінимо значення a
a = 10;
console.log(a); // 10
// Значення b не змінилося, оскільки це окрема копія
console.log(b); // 5

// --------------------------------------------------
// Складні типи

// Складні типи - об'єкти, масиви, функції присвоюються за посиланням, 
// тобто змінна просто отримує посилання на вже існуючий об'єкт.



const a = ["Mango"];
// Оскільки a - це масив, в b записується посилання на вже існуючий
// масив в пам'яті. Тепер a і b вказують на той самий масив.
const b = a;
console.log(a); // ["Mango"]
console.log(b); // ["Mango"]

// Змінимо масив, додавши ще один елемент, використовуючи вказівник з a
a.push("Poly");
console.log(a); // ["Mango", "Poly"]

// b також змінилось, тому що b, як і a,
// просто містить посилання на те ж саме місце в пам'яті
console.log(b); // ["Mango", "Poly"]

// Результат повторюється
b.push("Ajax");
console.log(a); // ["Mango", "Poly", "Ajax"]
console.log(b); // ["Mango", "Poly", "Ajax"]

|============================
*/
// ______________________________________________________________________
// ======================================================================
// Методи масиву
// =============
/** Метод split(delimiter)
|============================
// Метод split(delimiter) перетворює рядок в масив, «розбиваючи» його роздільником delimiter. 
// Якщо роздільник - це порожній рядок, то створиться масив окремих символів.
// Роздільником може бути один або декілька символів.

const name = 'Mango';
console.log(name.split('')); // ["M", "a", "n", "g", "o"]

const message = 'JavaScript - це цікаво';
console.log(message.split(' ')); // ["JavaScript", "-", "це", "цікаво"]

// --------------------------------------------------------------------

const str = 'Hello word I`am JS';

// Разделитель по пустой строке.

const arr = str.split('');
console.log(arr); // ['H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'd', ' ', 'I', '`', 'a', 'm', ' ', 'J', 'S']

// Разделитель по пробелу.

const arr = str.split(' ');
console.log(arr); // ['Hello', 'word', 'I`am', 'JS']

// Разделитель по символу которого не нашел.

const arr = str.split(',');
console.log(arr); // ['Hello word I`am JS']

|============================
*/
// -------------
/** Метод join(delimiter)
|============================
// Метод масивів join(delimiter) об'єднує елементи масиву у рядок. 
// У рядку елементи будуть розділені символом або групою символів, зазначених в delimiter.
// Тобто ця операція протилежна методу рядків split(delimiter).

const words = ["JavaScript", "це", "цікаво"];
console.log(words.join("")); // "JavaScriptцецікаво"
console.log(words.join(" ")); // "JavaScript це цікаво"
console.log(words.join("-")); // "JavaScript-це-цікаво"
|============================
*/
// ----------------------------------------------
/** Метод indexOf()
|============================
// indexOf(value) повертає перший індекс, в якому елемент зі значенням value був знайдений в масиві,
// або число - 1, якщо такий елемент відсутній.
// Використовуйте indexOf тоді, коли необхідно отримати сам індекс елемента.

// .................0........1.......2.......3.......index

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];

// .................1........2.......3.......4.......position

console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1
|============================
*/
// ----------------------------------------------
/** Метод includes()
|============================

// includes(value) перевіряє, чи містить масив елемент зі значенням value і повертає true або false відповідно.
// Застосування цього методу корисне в ситуаціях, коли необхідно перевірити, чи є елемент в масиві і не важлива його позиція(індекс).

const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
console.log(clients.includes('Poly')); // true
console.log(clients.includes('Monkong')); // false

// Перевірка багатьох умов з includes()
// На перший погляд код наступного прикладу виглядає добре.

const fruit = 'apple';

if (fruit === 'apple' || fruit === 'strawberry') {
  console.log('It is a red fruit!');
}

// Однак, що робити, якщо у нас буде більше червоних фруктів, наприклад, ще вишня(cherry) або журавлина(cranberries) ?
// Чи будемо ми розширювати умову за допомогою додаткових ||?

const fruit = 'apple';

if (
  fruit === 'apple' ||
  fruit === 'strawberry' ||
  fruit === 'cherry' ||
  fruit === 'cranberries'
) {
  console.log('It is a red fruit!');
}

// Можемо переписати умову, використовуючи includes(), це дуже просто і масштабовано.

// Виносимо варіанти в масив
const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
const fruit = "cherry";
// Перевіряємо присутність елемента
const hasFruit = redFruits.includes(fruit);

if (hasFruit) {
  console.log(`${fruit} is a red fruit!`);
}

|============================
*/
// ----------------------------------------------
/** Методи push() і pop(), unshift() і shift()
|============================
// Додають або видаляють крайні елементи масиву.
// Працюють тільки з крайнім лівим і крайнім правим елементом, і не можуть вставити або видалити елемент з довільної позиції.

// -----------------------

// Метод push() додає один або декілька елементів наприкінці масиву, без необхідності зазначати індекси елементів, що додаються.
// Повертає довжину масиву після додавання елементів.

const numbers = [];

numbers.push(1);
console.log(numbers); // [1]

numbers.push(2);
console.log(numbers); // [1, 2]

numbers.push(3);
console.log(numbers); // [1, 2, 3]

numbers.push(4);
console.log(numbers); // [1, 2, 3, 4]

numbers.push(5);
console.log(numbers); // [1, 2, 3, 4, 5]

// -----------------------

// Метод pop() видаляє останній елемент з кінця масиву і повертає видалений елемент.
 // Якщо масив порожній, метод повертає undefined.

 const numbers = [1, 2, 3, 4, 5];

 console.log(numbers.pop()); //  5
 console.log(numbers); // [1, 2, 3, 4]

 console.log(numbers.pop()); //  4
 console.log(numbers); // [1, 2, 3]

 console.log(numbers.pop()); //  3
 console.log(numbers); // [1, 2]

 console.log(numbers.pop()); //  2
 console.log(numbers); // [1]

 console.log(numbers.pop()); //  1
 console.log(numbers); // []

|============================
*/
// ----------------------------------------------
/** Метод slice() 
 |============================
 
 // slice(begin, end) повертає новий масив, що містить копію частини вихідного масиву, не змінюючи його.
 // Копія створюється з begin і до, але не включно, end - індекси елементів вихідного масиву.
 
 const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
 console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]
 
 // Якщо begin і end не зазначені, буде створена повна копія вихідного масиву.
 
 const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
 console.log(clients.slice()); // ["Mango", Ajax", "Poly", "Kiwi"]
 
 // Якщо не зазначено end, копіювання буде зі start і до кінця вихідного масиву.
 
 const clients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
 console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]
 console.log(clients.slice(2)); // ["Poly", "Kiwi"]
 
 // Якщо значення start від'ємне, а end не зазначено - будуть скопійовані останні start елементи
 
 const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
 console.log(clients.slice(-2)); // ["Poly", "Kiwi"]
 
 |============================
 */
// ----------------------------------------------
/** Метод splice()
 |============================

    // Швейцарський ніж для роботи з масивами, якщо вихідний масив необхідно змінити.
    // Видаляє, додає і замінює елементи у довільному місці масиву.

    // =========
    // Видалення
    // =========
    // Щоб видалити елементи в масиві, передаються два аргументи.

    splice(position, num);

    // - position - вказує на позицію (індекс) першого елемента для видалення
    // - num - визначає кількість елементів, що видаляються

    // Метод splice змінює вихідний масив і повертає масив, що містить видалені елементи.
    // Наприклад, у нас є масив оцінок, який містить п'ять чисел від 1 до 5.

    const scores = [1, 2, 3, 4, 5];

    // Видаляємо три елементи масиву, починаючи з першого елемента (індекс 0)
    const deletedScores = scores.splice(0, 3);

    // Тепер масив scores містить два елементи
    console.log(scores); // [4, 5]

    // А масив deletedScores містить три видалені елементи
    console.log(deletedScores); // [1, 2, 3]

    // На зображенні показаний виклик методу score.splice (0, 3) з прикладу.

    // !ЦІКАВО
    // На практиці, значення, що повертається(масив видалених елементів), використовується рідко.
    // Переважно, просто необхідно видалити елементи з масиву.

    // =========
    // Додавання
    // =========
    // Для того, щоб додати один або декілька елементів в масив,
    // необхідно передати три або більше аргументи, за такої умови,
    // другий аргумент повинен дорівнювати нулю.

    // splice(position, 0, new_element_1, new_element_2, ...)

    // - Аргумент position вказує початкову позицію в масиві, куди будуть вставлені нові елементи.
    // - Другий аргумент - це нуль, він говорить методу не видаляти елементи в місці додавання нових.
    // - Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.
    // Наприклад, у нас є масив з назвами кольорів у вигляді рядків. Додамо новий колір перед елементом з індексом 2.

    const colors = ['red', 'green', 'blue'];

    colors.splice(2, 0, 'purple');
    console.log(colors); // ["red", "green", "purple", "blue"]

    // На малюнку показаний виклик методу colors.splice(2, 0, 'purple') з прикладу.

    // Можна додати довільну кількість елементів, передавши четвертий, п'ятий аргумент тощо.

    const colors = ['red', 'green', 'blue'];

    colors.splice(1, 0, 'yellow', 'pink');
    console.log(colors); // ["red", "yellow", "pink", "green", "blue"]

    // =========
    // Заміна
    // =========
    // Заміна - це операція додавання, в якій видаляються елементи в місці додавання нових.
    // Для цього необхідно передати мінімум три аргументи.Кількість елементів, що видаляються і додаються, може не збігатися.

    // splice(position, num, new_element_1, new_element_2, ...)

    // - position - вказує на позицію (індекс) першого елемента для видалення
    // - num - визначає кількість елементів, що видаляються
    // - Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.
    // Наприклад, у нас є масив мов програмування з чотирьох елементів.

    const languages = ['C', 'C++', 'Java', 'JavaScript'];

    // Заміняємо елемент з індексом 1 на новий
    languages.splice(1, 1, 'Python');
    console.log(languages); // ["C", "Python", "Java", "JavaScript"]

    // Заміняємо один елемент (з індексом 2) на декілька
    languages.splice(2, 1, 'C#', 'Swift', 'Go');
    console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]

    // На зображенні показаний виклик методу languages.splice(1, 1, 'Python') з прикладу.

 |============================
 */
// ----------------------------------------------
/** Метод concat()
|============================

// Об'єднує два або більше масивів в один. Він не змінює масив, на якому викликається, а повертає новий.
// Порядок аргументів методу впливає на порядок елементів нового масиву.

const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Monkong", "Singu"];

const allClientsWithOldFirst = oldClients.concat(newClients);
console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

const allClientsWithNewFirst = newClients.concat(oldClients);
console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
console.log(newClients); // ["Monkong", "Singu"]

|============================
*/
// ----------------------------------------------
/** Метод reverse()
|============================
Метод reverse() обращает порядок элементов в массиве в обратном направлении, то есть делает первый элемент последним, а последний — первым. Метод изменяет массив, по отношению к которому вызван, и возвращает ссылку на изменённый массив.

const array1 = ['one', 'two', 'three'];
console.log('array1:', array1); // "array1:" Array ["one", "two", "three"]

const reversed = array1.reverse();
console.log('reversed:', reversed); // "reversed:" Array ["three", "two", "one"]

// Осторожно: обратный ход деструктивен — он изменяет исходный массив.
console.log('array1:', array1); // "array1:" Array ["three", "two", "one"]
|============================
*/
// ______________________________________________________________________
// ======================================================================

// const clients = ['Mango', 'Poly', 'Ajax'];
// ------------------------------------
// console.log(clients.length);

// console.log(clients[0]);
// console.log(clients[1]);
// console.log(clients[2]);
// ------------------------------------
// clients[0] = 'Kiwi';

// console.log(clients[0]);

// console.log(clients);
// ------------------------------------
// const lastElementIndex = clients.length - 1;
// console.log(lastElementIndex);
// console.log(clients[lastElementIndex]);
// ------------------------------------
// for (let i = 0; i < clients.length; i += 1) {
//   console.log(clients[i]);
// }
// ------------------------------------
// for (const client of clients) {
//   console.log(client);
// }
// ------------------------------------
// const string = 'javascript';

// for (const character of string) {
//   console.log(character);
// }
// ________________________________________________________________________________________
// Задача:
// Будемо шукати ім'я клієнта в масиві імен, якщо знайшли - перериваємо цикл, оскільки немає сенсу шукати далі, імена у нас унікальні.

// const clients = ['Mango', 'Poly', 'Ajax'];
// const clientNameToFind = 'Poly';

/** Решение:
|============================

const clients = ['Mango', 'Poly', 'Ajax'];
const clientNameToFind = 'Poly';
let message;

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }
  message = "Клієнт з таким ім'ям відсутній в базі даних!";
}
console.log(message);

// -------- 2й вариант ---------

const clients = ['Mango', 'Poly', 'Ajax'];
const clientNameToFind = 'Poly';
let message = "Клієнт з таким ім'ям відсутній в базі даних!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клієнт з таким ім'ям є в базі даних!";
    break;
  }
}
console.log(message);

|============================
*/
// ________________________________________________________________________________________

// Використовуємо цикл для виведення тільки чисел, більших за певне значення.

// const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
// const threshold = 15;

/** Решение:
|============================

// ----- Вариант-1 for ----------------

for (let i = 0; i < threshold; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }
  console.log(numbers[i]);
}

// ----- Вариант-1 for of --------------

for (const number of numbers) {
  if (number < threshold) {
    continue;
  }
  console.log(number);
}

|============================
*/
// _________________________________________________________________________________________
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// =========================================================================================
// Repeta модуль-2 занятие 1 Масивы
// ================================
/** Масиві и работа сними.
|============================

const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

console.log(friends);
console.log(friends.length);
console.table(friends);

// -------------------------------------------------------
// Последний индекс

const lastIndex = friends.length - 1;
console.log(lastIndex);

// -------------------------------------------------------

console.log(friends[0]);
console.log(friends[friends.length - 1]);
Это тоже самое что: console.log(['Mango', 'Kiwi', 'Poly', 'Ajax'][0]);

// -------------------------------------------------------

// Запись в масив (перезапись)

const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

friends[0] = 'Orange';

console.table(friends); // ['Orange', 'Kiwi', 'Poly', 'Ajax'];

|============================
*/
// ________________________________________________________________________________________
/** Примитивные типы и Сложные типы
|============================

// Примитивные типы (Передача по значению) Создается точная копия.

// При переназначении значения переменной - создается отдельная ечейка(копия) в памяти.

// let a = 10;
// let b = a;

// console.log(a); // 10
// console.log(b); // 10

// a = 20;

// console.log(a); // 20
// console.log(b); // 10

// =============================================================

// Сложные типы (Передача по ссылке) Копируются по ссылке.

// При создании сложного типа как (масив)
// выделяется отдельное место в памяти для записи этого масива,
// а в переменную записывается ссылка на место где находится этот масив.

// const c = [1, 2, 3];
// const d = c;

// // console.log(c);
// console.log(c); // [1, 2, 3]
// console.log(d); // [1, 2, 3]

// c[0] = 500;

// console.log(c); // [500, 2, 3]
// console.log(d); // [500, 2, 3]

// console.log(c === d); // true - потому что это один и тот же масив, к переменным C и D присвоены ссылки на одну ячеку в памяти где лежит этот масив.

// console.log([1, 2, 3] === [1, 2, 3]); // false - потому что это разные масивы, они не равны, лежат они в разных местах памяти.

|============================
*/
// ________________________________________________________________________________________
/** Цикл for и Цикл for of
|============================
//  Цикл for

//  Перебор масива (итерация масива)

// Задача: Нужно вывести в консоль все значения этого масива

// const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

// console.table(friends);

// console.log(friends.length - 1);

// -----------------------------

// const lastIndex = friends.length - 1;

// for (let i = 0; i <= friends.length - 1; i += 1) {}

// for (let i = 0; i <= lastIndex; i += 1) {
//   console.log('qqqwe');
//   console.log(i);
//   console.log(friends[i]);
// }
// -----------------------------

// for (let i = 0; i < friends.length; i += 1) {
//   friends[i] += '-1';
// }
// console.table(friends);

// =================================================================

//  Цикл for of

// Используем Цикл for of тогда когда нам в задаче не нужен индекс или нам не нужно изменять элемент масива.

// const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];

// // for(const variable of iterable) {}

// for (const friend of friends) {
//   console.log(friend);
// }
|============================
*/
// ________________________________________________________________________________________
// Задача-1
// Посчитать общую сумму покупок в корзине.

// const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

/** Решение:
|============================

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

// Наши действия.
// 1 перебрать массив
// 2 сделать переменную total до цикла
// 3 каждый элемент приплюслвать к total

// ----- Вариант-1 for of ------------

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];
let sum = 0;

for (const value of cart) {
  sum += value;
}
console.log('sum: ', sum);

// ----- Вариант-2 for ----------------

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];
let sum = 0;

for (let i = 0; i < cart.length; i += 1) {
  sum += cart[i];
}
console.log('sum: ', sum);

|============================
*/
// ________________________________________________________________________________________
// Задача-2
// Добавить такс (добавить проценты к каждому числу).

// const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

/** Решение:
|============================

const cart = [54, 28, 105, 70, 92, 17, 120, 12, 25, 90];

for (let i = 0; i < cart.length; i += 1) {
  cart[i] = Math.round(cart[i] * 1.1);
}
console.log(cart);

|============================
*/
// ________________________________________________________________________________________
// Задача-3
// Напиши скрипт который подсчитывает сумму всех чётных чисел в массиве.

// const numbers = [1, 5, 8, 9, 12, 4, 15, 27, 30, 18, 14];

/** Решение:
|============================
const numbers = [1, 5, 8, 9, 12, 4, 15, 27, 30, 18, 14];
let sum = 0;

// ----- Вариант-1 ----------------------------------

for (const number of numbers) {
  if (number % 2 === 0) {
    // console.log('четное: ', number);
    sum += number;
  }
}
console.log('сумма четных: ', sum);

// ----- Вариант-2 (логика от обратного)-------------

for (const number of numbers) {
  if (number % 2 !== 0) {
    // console.log('Эту итерацию нужно пропустить', number);
    continue;
  }
  // console.log(`${number} - четное число!`);
  sum += number;
}
console.log('сумма четных: ', sum);

// ----- Вариант-3 ----------------------------------

for (let i = 0; i < numbers.length; i += 1) {
  const number = numbers[i];

  if (number % 2 === 0) {
    console.log('четное: ', number);
    sum += number;
  }
}
console.log('сумма четных: ', sum);

// ----- Вариант-4 ----------------------------------

for (let i = 0; i < numbers.length; i += 1) {
  // console.log(numbers[i]);
  if (numbers[i] % 2 === 0) {
    console.log('четное: ', numbers[i]);
    sum += numbers[i];
  }
}
console.log('сумма четных: ', sum);

|============================
*/
// ________________________________________________________________________________________
// Задача-4
//  * Напиши скрипт поиска логина
//  * - Если логина нет, вывести сообщение 'Пользователь [логин] не найден.'
//  * - Если нашли логин, вывести сообщение 'Пользователь [логин] найден.'
//  * - Сначала через for
//  * - Потом через for...of
//  * - Логика break
//  * - Метод includes() с тернарным оператором

// const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
// const loginToFind = 'aj4xth3m4n';

// ===================================================
/** Решение Варианты includes() с тернарным оператором
|============================

// Этот метод логики называется дикларативный код. 
// Метод includes() под капотом делает переборку и сравнения. Называется Абстракция.

const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
const loginToFind = 'aj4xth3m4n';

const message = logins.includes(loginToFind)
  ? `Пользователь ${loginToFind} найден.`
  : `Пользователь ${loginToFind} не найден.`;

console.log(message);

|============================
*/
// ===================================================
/** Решение Варианты for of 
|============================

const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
const loginToFind = 'aj4xth3m4n';

// -------------------------------------------------------------------
// ----- Вариант for of - 1й вар. ------------------------------------

let message = '';

for (const login of logins) {
  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
  } else {
    message = `Пользователь ${loginToFind} не найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 2й вар. ------------------------------------

let message = '';

for (const login of logins) {
  if (login !== loginToFind) {
    message = `Пользователь ${loginToFind} не найден.`;
  } else {
    message = `Пользователь ${loginToFind} найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 3й вар. Логика break -----------------------

let message = `Пользователь ${loginToFind} не найден.`;

for (const login of logins) {
  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 4й вар. Логика break -----------------------

let message = '';

for (const login of logins) {
  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
  message = `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

// -------------------------------------------------------------------
// ----- Вариант for of - 5й вар. с тернарным оператором -------------

let message = '';

for (const login of logins) {
  message =
    login === loginToFind
      ? `Пользователь ${loginToFind} найден.`
      : `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

|============================
*/
// ===================================================
/** Решение Варианты for
|============================

const logins = ['m4ngoDoge', 'k1widab3st', 'poly1scute', 'aj4xth3m4n'];
const loginToFind = 'aj4xth3m4n';

// -------------------------------------------------------------------
// ----- Варианты for - 1й вар. --------------------------------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login !== loginToFind) {
    message = `Пользователь ${loginToFind} не найден.`;
  } else {
    message = `Пользователь ${loginToFind} найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 2й вар. --------------------------------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
  } else {
    message = `Пользователь ${loginToFind} не найден.`;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 3й вар. Логикф break -------------------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
  message = `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 4й вар. Логика break -------------------------

let message = `Пользователь ${loginToFind} не найден.`;

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  if (login === loginToFind) {
    message = `Пользователь ${loginToFind} найден.`;
    break;
  }
}
console.log(message);

// -------------------------------------------------------------------
// ----- Варианты for - 5й вар. с тернарным оператором ---------------

let message = '';

for (let i = 0; i < logins.length; i += 1) {
  const login = logins[i];

  message =
    login === loginToFind
      ? `Пользователь ${loginToFind} найден.`
      : `Пользователь ${loginToFind} не найден.`;
}
console.log(message);

|============================
*/
// ===================================================
// ________________________________________________________________________________________
// Задача-5
//  * Напиши скрипт поиска самого маленького числа в массиве,
//  * при условии что числа уникальные(не повторяются).

// const numbers = [51, 18, 13, 24, 7, 85, 19];

/** Решение:
|============================

const numbers = [51, 18, 13, 24, 7, 85, 19];

// ----- Вариант Самое маленькое число ------------

let smallNumber = numbers[0];

for (const number of numbers) {
  if (number < smallNumber) {
    smallNumber = number;
  }
}

console.log(smallNumber);

// ----- Вариант Самое большое число---------------

let bigNumber = numbers[0];

for (const number of numbers) {
  if (number > bigNumber) {
    bigNumber = number;
  }
}

console.log(bigNumber);

|============================
*/
// ________________________________________________________________________________________
// Задача-6
//  * Напиши скрипт, который объединяет все элементы массива в одно строковое значение.
//  * Элементов может быть произвольное кол-во.
//  * Пусть элементы массива  в строке будут разделены запятой.
//  * - Сначала через for
//  * - Потом через join()

// const friends = ['Mango', 'Poly', 'Kiwi', 'Ajax'];

/** Решение:
|============================

// ----- Вариант-1 for of -------------------------

let string = '';

for (const friend of friends) {
  string += friend + ',';
}
string = string.slice(0, string.length - 1);

console.log(string);

// ----- Вариант-2 for ------------------------------

let string = '';

for (let i = 0; i < friends.length; i += 1) {
  const friend = friends[i];
  string += friend + ',';
}
string = string.slice(0, string.length - 1);
console.log(string);

// ----- Вариант-3 join() ---------------------------

const message = friends.join(',');

console.log(message);

|============================
*/
// ________________________________________________________________________________________
// Задача-7
// * Напиши скрипт который заменяет регистр каждого символа в строке на противоположный.
// * Например, если строка «JavaScript», то на выходе должена быть строка «jAVAsCRIPT».

// const string = 'JavaScript';

/** Решение:
|============================

const string = 'JavaScript';

// ----- Вариант-1 Решение современное с тернарным оператором ----------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  const isInLowerCase = letter === letter.toLowerCase();
  invertedString += isInLowerCase ? letter.toUpperCase() : letter.toLowerCase();
}
console.log(invertedString);

// ----- Вариант-2 Решение современное с тернарным оператором ----------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  invertedString +=
    letter === letter.toLowerCase()
      ? letter.toUpperCase()
      : letter.toLowerCase();
}
console.log(invertedString);

// ----- Вариант-3 Решение-Old shool if else --------------------------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  if (letter === letter.toUpperCase()) {
    invertedString += letter.toLowerCase();
  } else {
    invertedString += letter.toUpperCase();
  }
}
console.log(invertedString);

// ----- Вариант-4 Решение Непонятное с тернарным оператором ----------------

const letters = string.split('');
let invertedString = '';

for (const letter of letters) {
  invertedString +=
    letter === letter.toLocaleLowerCase()
      ? (invertedString += letter.toLocaleUpperCase())
      : (invertedString += letter.toLocaleLowerCase());
}
console.log(invertedString);

|============================
*/
// ________________________________________________________________________________________
// Задача-8
//  * Делаем slug в URL из названия статьи (например на dev.to)
//  * Заголовок статьи состоит только из букв и пробелов
//  * - Нормализируем строку
//  * - Разбиваем по словам
//  * - Сшиваем в строку с разделителями
// Должно получиться top-10-benefits-of-react-framework

// const title = 'Top 10 benefits of React framework';

/** Решение:
|============================
const title = 'Top 10 benefits of React framework';

// ----- Вариант-1 Решение Решение современное (Метод чейнинг) ------

const slug = title.toLowerCase().split(' ').join('-');
console.log(slug);

// ----- Вариант-2 Решение-Old shool --------------------------------

const normilizedTitle = title.toLowerCase();
// console.log(normilizedTitle);

const words = normilizedTitle.split(' ');
// console.log(words);

const slug = words.join('-');
console.log(slug);

|============================
*/
// ________________________________________________________________________________________
// Задача-9
// * Напиши скрипт который считает сумму элементов двух массивов.

// const array1 = [5, 10, 15, 20];
// const array2 = [10, 20, 30];

/** Решение:
|============================
const array1 = [5, 10, 15, 20];
const array2 = [10, 20, 30];

// ----- Вариант-1 Хороший метод с .concat() -----------------------------------

let total = 0;

const numbers = array1.concat(array2);

for (const number of numbers) {
  total += number;
}
console.log(total);

// ----- Вариант-2 Плохой вариант, но рабочий ----------------------------------

let total = 0;

for (let i = 0; i < array1.length; i += 1) {
  total += array1[i];
}
for (let i = 0; i < array2.length; i += 1) {
  total += array2[i];
}
console.log(total);

|============================
*/
// ________________________________________________________________________________________
// Задача-10
//  * Работем с коллекцией карточек в trello - Метод splice()
//  * - Удалить четвертую карточку из масива.
//  * - Добавить 'Карточка-x' и 'Карточка-y' в середину масива на 3ю и 4ю позицию.
//  * - Обновить заменить 'Карточка-2' на 'Карточка-8' в масиве.

// const cards = [
//   'Карточка-1',
//   'Карточка-2',
//   'Карточка-3',
//   'Карточка-4',
//   'Карточка-5',
// ];
// console.table(cards);

/** Удаление, Добавление, Обнавление масива. Методы indexOf(), .splice()
|============================

const cards = [
  'Карточка-1',
  'Карточка-2',
  'Карточка-3',
  'Карточка-4',
  'Карточка-5',
];

console.table(cards);

// * Удаление (по индексу), метод indexOf()
// ----------------------------------------------------------------
const cardToRemove = 'Карточка-3';
const index = cards.indexOf(cardToRemove);
console.log(index);

cards.splice(index, 1);
console.table(cards);

// * Добавление (по индексу) метод .splice() в произвольном месте.
// ----------------------------------------------------------------
const cardToInsert = 'Карточка-6';
const index = 3;

cards.splice(3, 0, 5, 10, 20); // Пример

cards.splice(index, 0, cardToInsert);
console.table(cards);

// * Обновление (по индексу)
// ----------------------------------------------------------------
const cardToUpdate = 'Карточка-4';
const index = cards.indexOf(cardToUpdate);

console.log(index);
cards.splice(index, 1, 'Обновленная карточка-4');

console.table(cards);

|============================
*/

// _________________________________________________________________________________________
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// =========================================================================================
// Артем Рисич модуль-2 занятие 1 Масивы
// ================================
/** Перебор масива в масиве
|============================
// ............0.....1......2......3.......4......index

const array = [1, 'Hello', null, true, [1, 2, 3]];

// ............1.....2......3......4.......5......position

for (let i = 0; i < Array.length; i += 1) {
  const item = array[i];
  if (Array.isArray(item)) {
    for (let j = 0; j < item.length; j += 1) {
      console.log(item[j]);
    }
    continue;
  }
  console.log(array[i]);
}
|============================
*/
// ---------------------------------------------------
/** Перебор масива с помощью While
|============================
const array = [1, 'Hello', null, true, [1, 2, 3]];

let i = 0;
while (i < array.length) {
  console.log(array[i]);
  i += 1;
}
|============================
*/
// ---------------------------------------------------
/** Замена строки 'string' на false 2ва примера for и while
|============================

const array = [1, 'Hello', null, true, [1, 2, 3]];
// ----------------------------------------------

for (let i = 0; i < array.length; i += 1) {
  if (typeof array[i] === 'string') {
    array[i] = false;
  }
}
console.log('for', array);

// ----------------------------------------------

let i = 0;

while (i < array.length) {
  if (typeof array[i] === 'string') {
    array[i] = false;
  }
  i += 1;
}
console.log(array);

// ----------------------------------------------

// for of Не работает в этом случае. Потому что он не изменяет масив а копирует его.

for (let item of array) {
  if (typeof item === 'string') {
    item = false;
  }
}
console.log('for of', array);
|============================
*/
// ---------------------------------------------------
/** Присвоение по значению и по ссылке. (Примитивный и сложный тип данных)
|============================

// Присвоение по значению (примитивный тип данных)
let value = 1;
let test = value;

value += 10;

console.log('value:', value); // 11
console.log('test:', test); // 1

// Присвоение по ссылке (сложный тип данных)
const array = [1, 2, 3, 4, 5];
const copy = array;

array.push(6, 7);
copy.push(8, 9);

console.log(array); // [1,2,3,4,5,6,7,8,9]
console.log(copy); // [1,2,3,4,5,6,7,8,9]
console.log(array === copy); // true

// --------------------------------------------

console.log(1 === 1); // true
console.log('hello' === 'hello'); // true
console.log([1, 2, 3] === [1, 2, 3]); // false

|============================
*/
// ---------------------------------------------------
/** Разворот масива или строки. Метод масива .reverse()
|============================
// Разворот масива

const str = 'Hello word I`am JS';
const arr = str.split(' ');
const reversed = arr.reverse();
const newStr = reversed.join(' ');
console.log(newStr); // JS I`am word Hello

// Разворот строки

const str = 'Hello word I`am JS';
const arr = str.split('');
const reversed = arr.reverse();
const newStr = reversed.join('');
console.log(newStr); // JS I`am word Hello

|============================
*/
// ---------------------------------------------------

// _________________________________________________________________________________________
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// =========================================================================================
// Георг модуль-2 занятие 1 Масивы
// ================================
/** В чем отличия i++ и i += ??????
|============================

// ----- i++ (post increment) vs i += 1 vs ++i (pre increment) -----
let x = 1;

console.log((x += 1)); // 2
console.log((x += 1)); // 3
console.log((x += 1)); // 4
console.log((x += 1)); // 5
console.log(x); // 5

let y = 1;

console.log(y++); // 1
console.log(y++); // 2
console.log(y++); // 3
console.log(y++); // 4
console.log(y); // 5

let q = 1;

console.log(++q); // 2
console.log(++q); // 3
console.log(++q); // 4
console.log(++q); // 5
console.log(q); // 5

|============================
*/

// _________________________________________________________________________________________
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// =========================================================================================
// ЗАДАЧИ-ПРАКТИКА (Артем Рисич и Георг) модуль-2 занятие 1 Масивы
// ===============================================================
// Example 1 - Базові операції з масивом
// Створіть масив genres з елементами «Jazz» та «Blues».
// Додайте «Рок-н-рол» до кінця.
// Виведіть у консоль перший елемент масиву.
// Виведіть у консоль останній елемент масиву. Код повинен працювати для масиву довільної довжини.
// Видаліть перший елемент та виведіть його в консоль.
// Вставте «Country» та «Reggae» на початок масиву.

// const genres = ;
// --------------------------
/** Решение: Георг
|============================

// Створіть масив genres.
const genres = [];
console.log(genres);

// -------------------------------

// Додайте до масиву genres елементи «Jazz» та «Blues».
genres.push('Jazz', 'Blues');
console.table(genres);

// -------------------------------

// Додайте «Рок-н-рол» до кінця.
genres.push('Рок-н-рол');
console.log(genres);

// -------------------------------

// Виведіть у консоль перший елемент масиву.
console.log(genres[0]);

const firstItem = genres[0];
console.log(firstItem);

// -------------------------------

// Виведіть у консоль останній елемент масиву. Код повинен працювати для масиву довільної довжини.
console.log(genres[genres.length - 1]);

const lastItem = genres[genres.length - 1];
console.log(lastItem);

// -------------------------------

// Видаліть перший елемент та виведіть його в консоль.
// Вариант-1
console.log(genres.splice(0, 1));
// Вариант-2
console.log(genres.shift());

// -------------------------------

// Вставте «Country» та «Reggae» на початок масиву.
// Вариант-1
genres.splice(0, 0, 'Country', 'Reggae');
console.log(genres);
// Вариант-2
genres.unshift('Country', 'Reggae');
console.log(genres);

|============================
*/
// ________________________________________________________________________________________
// Example 2 - Масиви та рядки
// Напиши скрипт для обчислення площі прямокутника зі сторонами, значення яких зберігаються у змінній values у вигляді рядка.
// Значення гарантовано розділені пробілом.

// const values = '8 11';
// --------------------------
/** Решение: Artem
|============================

const values = '8 11';

// Решение Артем -----

const array = values.split(' ');
const first = Number(array[0]);
const last = Number(array[array.length - 1]);
const result = num1 * num2;
console.log(result);
|============================
*/
// ---------------------------------------------
/** Решение: Георг
|============================

const values = '8 11';

const numbersRectangle = values.split(' ');
const number1 = Number(numbersRectangle[0]);     // Вариант-1 (приведение к числу)
const number2 = parseInt(numbersRectangle[1]);   // Вариант-2 (приведение к числу)

const area = number1 * number2;
console.log(area);

|============================
*/
// ---------------------------------------------
/** Мой вариант
|============================

const values = '8 11';

const array = values.split(' ');
const num1 = Number(array[0]);
const num2 = Number(array[1]);
const area = num1 * num2;
console.log(area);
|============================
*/
// ________________________________________________________________________________________
// Example 3 - Перебір масиву
// Напиши скрипт для перебору масиву fruits циклом for.
// Для кожного елемента масиву виведи в консоль рядок у форматі
// номер_елемента: значення_елемента.
// Нумерація елементів повинна починатися з 1.

// const fruits = ['🍎', '🍇', '🍑', '🍌', '🍋'];
// --------------------------
/** Решение: Artem
|============================

const fruits = ['🍎', '🍇', '🍑', '🍌', '🍋'];

// Вариант-1 ----------------

for (let i = 0; i < fruits.length; i += 1) {
  const result = `${i + 1}: ${fruits[i]}`;
  console.log(result);
}

// Вариант-2 ----------------

for (let i = 0, n = 1; i < fruits.length; i += 1, n += 1) {
  const result = `${n}: ${fruits[i]}`;
  console.log(result);
}

// Вариант-3 ----------------

for (let i = 0, n = 1; i < fruits.length, n <= fruits.length; i += 1, n += 1) {
  const result = `${n}: ${fruits[i]}`;
  console.log(result);
}

|============================
*/
// ---------------------------------------------
/** Решение: Георг
|============================

const fruits = ['🍎', '🍇', '🍑', '🍌', '🍋'];

// ----- Вариант-1 for of -----------------------------

let item = 0;
let message = '';

for (const fruit of fruits) {
  message = `${(item += 1)}: ${fruit}`;
  console.log(message);
}

// ----- Вариант-2 for --------------------------------

const fruits = ['🍎', '🍇', '🍑', '🍌', '🍋'];

let i = 1;

for (let i = 0; i < fruits.length; i += 1) {
  console.log(`${i + 1}: ${fruits[i]}`);
}

|============================
*/
// ________________________________________________________________________________________
// Example 4 - Масиви та цикли
// Напиши скрипт, який виводить у консоль ім'я та телефонний номер користувача.
// У змінних names та phones зберігаються рядки імен та телефонних номерів, розділені комами.
// Порядковий номер імен та телефонів у рядках вказують на відповідність.
// Кількість імен та телефонів гарантовано однакова.

// const names = 'Jacob,William,Solomon,Artemis';
// const phones = '89001234567,89001112233,890055566377,890055566300';
// --------------------------
/** Решение: Artem
|============================

// Вариант-1 ----------------

const names = 'Jacob,William,Solomon,Artemis';
const phones = '89001234567,89001112233,890055566377,890055566300';

const namesArr = names.split(',');
const phonesArr = phones.split(',');

for (let i = 0; i < namesArr.length; i += 1) {
  console.log(`${namesArr[i]}: ${phonesArr[i]}`);
}

// Вариант-2 ----------------

Меняем переменные с const на let

let names = 'Jacob,William,Solomon,Artemis';
let phones = '89001234567,89001112233,890055566377,890055566300';

names = names.split(',');
phones = phones.split(',');

for (let i = 0; i < names.length; i += 1) {
  console.log(`${names[i]}: ${phones[i]}`);
}

// Вариант-3 ----------------

В том случае когда по кол-ву имена несовпадают с телефонами.

let names = 'Jacob,William,Solomon,Artemis';
let phones = '89001234567,89001112233,890055566377';

names = names.split(',');
phones = phones.split(',');
for (let i = 0; i < names.length, i < phones.length; i += 1) {
  console.log(`${names[i]}: ${phones[i]}`);
}

|============================
*/
// ---------------------------------------------
/** Решение: Георг
|============================
// const names = 'Jacob,William,Solomon,Artemis';
// const phones = '89001234567,89001112233,890055566377,890055566300';

// Наши план
// 1) Преобразовать текст в масив.
// 2) Перебрать масив.
// 3) Создать шаблонный текст. `Jacob: 89001234567`

// Действие-1 Преобразовать текст в масив.
const namesArr = names.split(',');
// console.log(namesArr);
const phonesArr = phones.split(',');
// console.log(phonesArr);

// Действие-2 Перебрать масив.
for (let i = 0; i < namesArr.length; i += 1) {
  // console.log(namesArr[i]);
  // console.log(phonesArr[i]);

  // Действие-3 Создаём шаблонный текст. `Jacob: 89001234567`.
  console.log(`${namesArr[i]}: ${phonesArr[i]}`);
}

|============================
*/
// ________________________________________________________________________________________
// Example 5 - Масиви та рядки
// Напиши скрипт, який виводить у консоль усі слова рядка крім першого і останнього.
// Результуючий рядок не повинен починатися або закінчуватися символ пробілу.
// Скрипт повинен працювати для будь - якого рядка.

// const string = 'Welcome to the future';
// --------------------------
/** Решение: Артем
|============================

const string = 'Welcome to the future';

// Вариант-1 ----------------

const result = string.split(' ').slice(1, -1).join(' ');
console.log(result);

// Вариант-2 ----------------

const arr = string.split(' ');
arr.shift();
arr.pop();
const result = arr.join(' ');
console.log(result);

|============================
*/
// ---------------------------------------------
/** Решение: Георг
|============================
const string = 'Welcome to the future';

// Наши план
// 1) Преобразовать текст в масив.
// 2) Удалить первый элемент масива.
// 3) Удалить последний элемент масива.
// 4) Преобразовать масив в тект.

const wordsArr = string.split(' ');        // 1 Преобразовать текст в масив.
wordsArr.shift();                          // 2 Удалить первый элемент масива.
wordsArr.pop();                            // 3 Удалить последний элемент масива.
const newString = wordsArr.join(' ');      // 4 Преобразовать масив в тект.

console.log(newString);

console.log(`"${newString}"`);             // Для проверки, что в начале и в конце нет пробелов, ставим "".
|============================
*/
// ________________________________________________________________________________________
// Example 6 - Масиви та рядки
// Напиши скрипт, який «розгортає» рядок (зворотний порядок букв) і виводить його в консоль.

// const string = 'Welcome to the future';
// --------------------------
/** Решение: Артем
|============================
const string = 'Welcome to the future';

// Вариант-1 ----------------

const result = string.split('').reverse().join('');
console.log(result);

// Вариант-2 ----------------

const arr = string.split('');
const invertedArr = arr.reverse();
const invertedString = invertedArr.join('');
console.log(invertedString);
|============================
*/
// ---------------------------------------------
/** Решение: Георг
|============================

const string = 'Welcome to the future';

// Наши план
// 1) Преобразовать текст в масив букв.
// 2) Перевернуть текст.
//    (Вар - 1[1, 2, 3].reverse());
//    (Вар - 2 пройтись по масиву циклом и в новый пустой масив закинуть по одной букве в нужном нам порядке.);
// 3) Снова масив преобразовать в текст.

// ---------------------------------------------------
// ----- Вариант-1  легкое решение (чейнинг) ---------

const reversedString = string.split('').reverse().join('');

console.log(reversedString);

// ---------------------------------------------------
// ----- Вариант-2  легкое решение -------------------

const letters = string.split('');                   // 1 Преобразовать текст в масив букв.
const reversedLetter = letters.reverse();           // 2 Перевернуть текст.
const reversedString = reversedLetter.join('');     // 3 Снова масив преобразовать в текст.

console.log(reversedString);

// ---------------------------------------------------
// ----- Вариант-3 цикл for of -----------------------

// Преобразовать текст в масив букв.
// Перевернуть текст. Для этого создаем пустой масив.
// Проходим циклом for of по символам масива.
// Добавляем буквы в новый пустой масив.
// Снова масив преобразовать в текст.


const letters = string.split('');
const reversedLetter = [];

for (const letter of letters) {
  reversedLetter.unshift(letter);
}

const reversedString = reversedLetter.join('');

console.log(reversedString);

|============================
*/
// ________________________________________________________________________________________
// Example 7 - (4й модуль) Сортування масиву із циклом
// Напиши скрипт сортування масиву рядків в алфавітному порядку за першою літерою елемента.

// const langs = ['python', 'javascript', 'c++', 'haskel', 'php', 'ruby'];
// --------------------------
/**  Решение: Артем
|============================

const langs = ['python', 'javascript', 'c++', 'haskel', 'php', 'ruby'];
const langs = ['cpython', 'bjavascript', 'ac++', 'haskel', 'php', 'ruby'];

for (let i = 0; i < langs.length; i += 1) {
  if (langs[0] > langs[i]) {
    const result = langs.splice(i, 1)[0];
    langs.unshift(result);
  }
}
console.log(langs);

|============================
*/
// ---------------------------------------------
/** Решение: Георг
|============================

langs.sort(function (a, b) {
  const letter1 = a[0];
  const letter2 = b[0];

  return letter1.localeCompare(letter2);
});

console.log(langs);

|============================
*/
// ________________________________________________________________________________________
// Example 8 - Пошук елемента
// Напиши скрипт пошуку найменшого числа у масиві.
// Код повинен працювати для будь - якого масиву чисел.
// Використовуй цикл для розв'язання задачі.

// const numbers = [2, 17, 94, 1, 23, 37];
// let min;
// console.log(min); // 1

// --------------------------
/** Решение: Артем
|============================

const numbers = [2, 17, 94, 1, 23, 37];

let min = numbers[0];
for (const value of numbers) {
  if (value < min) {
    min = value;
  }
}
console.log(min); // 1
|============================
*/
// ---------------------------------------------
/** Решение: Георг
|============================
// const numbers = [2, 17, 94, 1, 23, 37];
// let min;
// console.log(min); // 1

// ----- Вариант-1  for of ---------------------------

const numbers = [2, 17, 94, 1, 23, 37];
let min = numbers[0];
console.log(min); // 1

for (const number of numbers) {
  if (number < min) {
    min = number;
  }
}
console.log(min);


// ----- Вариант-2  for ------------------------------

const numbers = [2, 17, 94, 1, 23, 37];
let min = numbers[0];

for (let i = 0; i < numbers.length; i += 1) {
  if (min > numbers[i]) {
    min = numbers[i];
  }
}
console.log(min); // 1

// ----- Вариант-3 -----------------------------------

const numbers = [2, 17, 94, 1, 23, 37];
let min;
console.log(Math.min(2, 17, 94, 1, 23, 37)); // 1


|============================
*/
// ________________________________________________________________________________________
